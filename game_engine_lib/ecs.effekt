module ecs

import resizable_array
import mutable/map
import io
import io/time
import stream

import game_engine_lib/core
import game_engine_lib/engine

interface ComponentManager {
  def nextComponentId(): Int
}

interface Component[T] {
  def getId(): Int
  def iterRO(archId: Int) { prog: => Unit / read[T] }: Unit / stop
  def iterRW(archId: Int) { prog: => Unit / { read[T], emit[T] } }: Unit / stop
  def add(archId: Int, value: T): Int
  def removeSwap(archId: Int, index: Int): Option[Int]
}

def component[T]() { prog: => Unit / Component[T] }: Unit / ComponentManager = {
  val componentId = do nextComponentId();
  val componentStore: Map[Int, ResizableArray[T]] = emptyMap();
  try {
    prog();
  } with Component[T] {
    def getId() = {
      resume(componentId)
    }
    def iterRO(archId) = {
      resume { { prog } =>
        val components = componentStore.unsafeGet(archId);
        var index = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (index < components.size()) {
              val component = components.unsafeGet(index);
              index = index + 1;
              component
            } else {
              do stop()
            }
          }
        }
      }
    }
    def iterRW(archId) = {
      resume { { prog } =>
        val components = componentStore.unsafeGet(archId);
        var readIndex = 0;
        var writeIndex = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (readIndex < components.size()) {
              val component = components.unsafeGet(readIndex);
              readIndex = readIndex + 1;
              component
            } else {
              do stop()
            }
          }
        } with emit[T] { value =>
          if (writeIndex < components.size()) {
            components.unsafeSet(writeIndex, value);
            writeIndex = writeIndex + 1;
          }
          resume(())
        }
      }
    }
    def add(archId, value) = {
      val components = componentStore.get(archId) match {
        case Some(components) => components
        case None() =>
          val components = resizableArray(4);
          componentStore.update(archId, components);
          components
      }
      val index = components.size();
      components.add(value);
      resume(index)
    }
    def removeSwap(archId, index) = {
      val components = componentStore.unsafeGet(archId);
      val swapped = components.removeSwap(index);
      if (components.size() == 0) {
        componentStore.delete(archId);
      }
      resume(swapped)
    }
  }
}

interface Components[T] {
  def getIds(): Array[Int]
  def iterTuplesRO(archId: Int) { prog: => Unit / read[T] }: Unit / stop
  def iterTuplesRW(archId: Int) { prog: => Unit / { read[T], emit[T] } }: Unit / stop
}

def zipComponents[
  A
]() { prog: => Unit / Components[(
  A
)] }: Unit / {
  Component[A]
} = {
  val componentIds = fromList([
    do getId[A]()
  ]);
  try {
    prog();
  } with Components[(
    A
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        try {
          prog();
        } with read[(
          A
        )] {
          resume {
            (
              do read[A]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        try {
          prog();
        } with read[(
          A
        )] {
          resume {
            (
              do read[A]()
            )
          }
        } with emit[(
          A
        )] { value =>
          value match {
            case a =>
              do emit(a);
          }
          resume(())
        }
      }
    }
  }
}

def zipComponents[
  A,
  B
]() { prog: => Unit / Components[(
  A,
  B
)] }: Unit / {
  Component[A],
  Component[B]
} = {
  val componentIds = fromList([
    do getId[A],
    do getId[B]
  ]);
  try {
    prog();
  } with Components[(
    A,
    B
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        try {
          prog();
        } with read[(
          A,
          B
        )] {
          resume {
            (
              do read[A](),
              do read[B]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        try {
          prog();
        } with read[(
          A,
          B
        )] {
          resume {
            (
              do read[A](),
              do read[B]()
            )
          }
        } with emit[(
          A,
          B
        )] { value =>
          value match {
            case (
              a,
              b
            ) =>
              do emit(a);
              do emit(b);
          }
          resume(())
        }
      }
    }
  }
}

def zipComponents[
  A,
  B,
  C
]() { prog: => Unit / Components[(
  A,
  B,
  C
)] }: Unit / {
  Component[A],
  Component[B],
  Component[C]
} = {
  val componentIds = fromList([
    do getId[A],
    do getId[B],
    do getId[C]
  ]);
  try {
    prog();
  } with Components[(
    A,
    B,
    C
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C]()
            )
          }
        } with emit[(
          A,
          B,
          C
        )] { value =>
          value match {
            case (
              a,
              b,
              c
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
          }
          resume(())
        }
      }
    }
  }
}

def zipComponents[
  A,
  B,
  C,
  D
]() { prog: => Unit / Components[(
  A,
  B,
  C,
  D
)] }: Unit / {
  Component[A],
  Component[B],
  Component[C],
  Component[D]
} = {
  val componentIds = fromList([
    do getId[A],
    do getId[B],
    do getId[C],
    do getId[D]
  ]);
  try {
    prog();
  } with Components[(
    A,
    B,
    C,
    D
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        with do iterRO[D](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        with do iterRW[D](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D]()
            )
          }
        } with emit[(
          A,
          B,
          C,
          D
        )] { value =>
          value match {
            case (
              a,
              b,
              c,
              d
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
              do emit(d);
          }
          resume(())
        }
      }
    }
  }
}

interface Query[T] {
  def update(): Unit
  def iterQueryRO() { prog: => Unit / read[T] }: Unit / stop
  def iterQueryRW() { prog: => Unit / { read[T], emit[T] } }: Unit / stop
}

interface System {
  def step(): Unit
}

def addSystemRO[T]() { action: T => Unit } { prog: => Unit / System }: Unit / { System, Query[T] } = {
  try {
    prog();
  } with System {
    def step() = {
      do step();
      try {
        with do iterQueryRO[T]();
        loop {
          action(do read());
        }
      } with stop {
        ()
      }
      resume(())
    }
  }
}

def addSystemRW[T]() { action: T => T } { prog: => Unit / System }: Unit / { System, Query[T] } = {
  try {
    prog();
  } with System {
    def step() = {
      do step();
      try {
        with do iterQueryRW[T]();
        loop {
          do emit(action(do read()));
        }
      } with stop {
        ()
      }
      resume(())
    }
  }
}

interface World {
  def stepWorld(): Unit / System
  def runWorld(): Unit / System
}

def defaultWorld() { prog: => Unit / { World, System, ComponentManager } } = {
  var lastComponentId = 0;
  try {
    prog();
  } with World {
    def stepWorld() = {
      resume {
        do step();
      }
    }
    def runWorld() = {
      resume {
        loop { { l } =>
          if (isInputEscape()) {
            l.break();
          }
          await(promise(box { wait(0) } ));
          do step();
        }
      }
    }
  } with System {
    def step() = {
      resume(())
    }
  } with ComponentManager {
    def nextComponentId() = {
      lastComponentId = lastComponentId + 1;
      resume(lastComponentId)
    }
  }
}