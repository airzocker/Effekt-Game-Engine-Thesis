module ecs

import resizable_array
import list
import mutable/map
import io
import io/time
import stream

import game_engine_lib/core

record Entity(id: Int)

record EntityData(archId: Int, componentIndex: Int)

record Arch(componentIds: List[Int], entities: ResizableArray[Entity])

effect nextComponentId(): Int

effect invalidArchID(): Unit

interface Component[T] {
  def getQueryId(): Option[Int]
  def iterRO(archId: Int) { prog: => Unit / read[T] }: Unit / { stop, invalidArchID }
  def iterRW(archId: Int) { prog: => Unit / { read[T], emit[T] } }: Unit / { stop, invalidArchID }
  def addComponent(archId: Int, value: T): Int
  def removeSwapComponent(archId: Int, index: Int): Option[Int]
  def getComponent(archId: Int, index: Int): T
  def setComponent(archId: Int, index: Int, value: T): Unit
}

interface Components[T] {
  def getQueryIds(): List[Int]
  def iterTuplesRO(archId: Int) { prog: => Unit / read[T] }: Unit / stop
  def iterTuplesRW(archId: Int) { prog: => Unit / { read[T], emit[T] } }: Unit / stop
  def addComponentTuple(archId: Int, value: T): Int
  def removeSwapComponentTuple(archId: Int, index: Int): Option[Int]
}

interface Resource[T] {
  def getResource(): T
  def setResource(value: T): Unit
}

interface ArchManager {
  def addUpdateQuery(componentIds: List[Int], WithoutIds: List[Int], archIds: Ref[ResizableArray[Int]]): Unit
  def updateQueries(): Unit
  def iterEntitiesRO(archId: Int) { prog: => Unit / read[Entity] }: Unit / stop
  // Returns archId
  def addEntity(componentIds: List[Int], entity: Entity): Int
  def removeSwapEntity(archId: Int, index: Int): Option[Int]
  def getEntity(archId: Int, index: Int): Entity
}

effect nextEntityId(): Int

interface EntityManager {
  def createEntity[T](components: T): Entity / Components[T]
  def destroyEntity[T](entity: Entity): Unit / Components[T]
  def getComponent[T](entity: Entity): T / Component[T]
  def setComponent[T](entity: Entity, value: T): Unit / Component[T]
  def hasEntity(entity: Entity): Bool
  def setReservedEntity[T](entity: Entity, components: T): Unit / Components[T]
}

interface Query[T, With, Without] {
  def foreachRO() { action: (Entity, T) => Unit }: Unit
  def foreachRW() { action: (Entity, T) => T }: Unit
}

interface System {
  def step(): Unit / EntityManager
}

def panicOnInvaildArchId() { prog: => Unit / invalidArchID }: Unit = {
  try {
    prog();
  } with invalidArchID {
    panic("Invalid archId!");
  }
}

def componentIdManager() { prog: => Unit / nextComponentId }: Unit = {
  var lastComponentId = 0;
  try {
    prog();
  } with nextComponentId {
    lastComponentId = lastComponentId + 1;
    resume(lastComponentId)
  }
}

// Commented out while buggy
/*
def addComponentT[T]() { prog: => Unit / Component[T] }: Unit / {
  EntityManager, nextComponentId, nextEntityId
} = {
  val componentId = do nextComponentId();
  var componentStore: Map[Int, ResizableArray[T]] = emptyMap();
  try {
    prog();
  } with Component[T] {
    def getQueryId() = {
      resume(Some(componentId))
    }
    def iterRO(archId) = {
      resume { { prog } =>
        val components = componentStore.get(archId) match {
          case Some(c) => c
          case None() => {
            do invalidArchID();
            resizableArray(0)
          }
        };
        var index = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (index < components.size()) {
              val component = components.unsafeGet(index);
              index = index + 1;
              component
            } else {
              do stop()
            }
          }
        }
      }
    }
    def iterRW(archId) = {
      resume { { prog } =>
        val components = componentStore.get(archId) match {
          case Some(c) => c
          case None() => {
            do invalidArchID();
            resizableArray(0)
          }
        };
        var readIndex = 0;
        var writeIndex = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (readIndex < components.size()) {
              val component = components.unsafeGet(readIndex);
              readIndex = readIndex + 1;
              component
            } else {
              do stop()
            }
          }
        } with emit[T] { value =>
          if (writeIndex < components.size()) {
            components.unsafeSet(writeIndex, value);
            writeIndex = writeIndex + 1;
          }
          resume(())
        }
      }
    }
    def addComponent(archId, value) = {
      val components = componentStore.get(archId) match {
        case Some(components) => components
        case None() =>
          val components = resizableArray(4);
          componentStore.update(archId, components);
          components
      }
      val index = components.size();
      components.add(value);
      resume(index)
    }
    def removeSwapComponent(archId, index) = {
      val components = componentStore.unsafeGet(archId);
      val swapped = components.removeSwap(index);
      if (components.size() == 0) {
        componentStore.delete(archId);
      }
      resume(swapped)
    }
    def getComponent(archId, index) = {
      resume(
        componentStore.get(archId) match {
          case Some(components) => components.unsafeGet(index)
          case None() => panic("Archetype with id " ++ archId.show() ++ " does not contain components of type id " ++ componentId.show() ++ "!");
        }
      )
    }
    def setComponent(archId, index, value) = {
      resume(
        componentStore.get(archId) match {
          case Some(components) => components.unsafeSet(index, value);
          case None() => panic("Archetype with id " ++ archId.show() ++ " does not contain components of type id " ++ componentId.show() ++ "!");
        }
      )
    }
  }
}

def addComponentsT[T]() { prog: => Unit / Components[T] }: Unit / {
  Component[T], EntityManager, nextComponentId, nextEntityId
} = {
  with panicOnInvaildArchId();
  val componentIds = [].addSome(do getQueryId[T]());
  try {
    prog();
  } with Components[T] {
    def getQueryIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[T](archId);
        prog();
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[T](archId);
        prog();
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        do addComponent(archId, value)
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      resume(
        do removeSwapComponent[T](archId, index)
      )
    }
  }
}

def addComponentOptionT[T]() { prog: => Unit / Component[Option[T]] }: Unit / Component[T] = {
  try {
    prog();
  } with Component[Option[T]] {
    def getQueryId() = {
      resume(None())
    }
    def iterRO(archId) = {
      resume { { prog } =>
        try {
          with do iterRO[T](archId);
          try {
            prog();
          } with read[Option[T]] {
            resume {
              Some(do read())
            }
          }
        } with invalidArchID {
          try {
            prog();
          } with read[Option[T]] {
            resume {
              None()
            }
          }
        }
      }
    }
    def iterRW(archId) = {
      resume { { prog } =>
        try {
          with do iterRW[T](archId);
          try {
            prog();
          } with read[Option[T]] {
            resume{
              Some(do read())
            }
          } with emit[Option[T]] { value =>
            value match {
              case Some(v) => do emit(v)
              case _ => ()
            }
            resume(())
          }
        } with invalidArchID {
          try {
            prog();
          } with read[Option[T]] {
            resume{
              None()
            }
          } with emit[Option[T]] { _ =>
            resume(())
          }
        }
      }
    }
    def addComponent(_, _) = {
      panic("Cannot addComponent for Option Component!");
    }
    def removeSwapComponent(_, _) = {
      panic("Cannot removeSwapComponent for Option Component!");
    }
    def getComponent(_, _) = {
      panic("Cannot getComponent for Option Component!");
    }
    def setComponent(_, _, _) = {
      panic("Cannot setComponent for Option Component!");
    }
  }
}

def addComponentsOptionT[T]() { prog: => Unit / Components[Option[T]] }: Unit / Component[T] = {
  val optionIds = [];
  try {
    prog();
  } with Components[Option[T]] {
    def getQueryIds() = {
      resume(optionIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        try {
          with do iterRO[T](archId);
          try {
            prog();
          } with read[Option[T]] {
            resume {
              Some(do read())
            }
          }
        } with invalidArchID {
          try {
            prog();
          } with read[Option[T]] {
            resume {
              None()
            }
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        try {
          with do iterRW[T](archId);
          try {
            prog();
          } with read[Option[T]] {
            resume{
              Some(do read())
            }
          } with emit[Option[T]] { value =>
            value match {
              case Some(v) => do emit(v)
              case _ => ()
            }
            resume(())
          }
        } with invalidArchID {
          try {
            prog();
          } with read[Option[T]] {
            resume{
              None()
            }
          } with emit[Option[T]] { _ =>
            resume(())
          }
        }
      }
    }
    def addComponentTuple(_, _) = {
      panic("Cannot addComponentTuple for Option Components!");
    }
    def removeSwapComponentTuple(_, _) = {
      panic("Cannot removeSwapComponentTuple for Option Components!");
    }
  }
}

def component[T]() { prog: => Unit / {
  Component[T], Components[T], Component[Option[T]], Components[Option[T]]
} }: Unit / {
  EntityManager, nextComponentId, nextEntityId
} = {
  with addComponentT[T]();
  with addComponentsT[T]();
  with addComponentOptionT[T]();
  with addComponentsOptionT[T]();
  prog();
}
*/

def component[T]() { prog: => Unit / {
  // Comment in the following comment for change
  Component[T], Components[T], Component[Option[T]]//, Components[Option[T]]
} }: Unit / {
  EntityManager, nextComponentId, nextEntityId
} = {
  val componentId = do nextComponentId();
  var componentStore: Map[Int, ResizableArray[T]] = emptyMap();
  val componentIds = [componentId];
  val optionIds = [];
  with panicOnInvaildArchId();
  try {
    try {
      try {
        try {
          prog();
        } with Components[Option[T]] {
          def getQueryIds() = {
            resume(optionIds)
          }
          def iterTuplesRO(archId) = {
            resume { { prog } =>
              try {
                with do iterRO[T](archId);
                try {
                  prog();
                } with read[Option[T]] {
                  resume {
                    Some(do read())
                  }
                }
              } with invalidArchID {
                try {
                  prog();
                } with read[Option[T]] {
                  resume {
                    None()
                  }
                }
              }
            }
          }
          def iterTuplesRW(archId) = {
            resume { { prog } =>
              try {
                with do iterRW[T](archId);
                try {
                  prog();
                } with read[Option[T]] {
                  resume{
                    Some(do read())
                  }
                } with emit[Option[T]] { value =>
                  value match {
                    case Some(v) => do emit(v)
                    case _ => ()
                  }
                  resume(())
                }
              } with invalidArchID {
                try {
                  prog();
                } with read[Option[T]] {
                  resume{
                    None()
                  }
                } with emit[Option[T]] { _ =>
                  resume(())
                }
              }
            }
          }
          def addComponentTuple(_, value) = {
            inspect(value);
            panic("Cannot addComponentTuple for Option Components!");
          }
          def removeSwapComponentTuple(_, _) = {
            panic("Cannot removeSwapComponentTuple for Option Components!");
          }
        }
      } with Components[T] {
        def getQueryIds() = {
          resume(componentIds)
        }
        def iterTuplesRO(archId) = {
          resume { { prog } =>
            with do iterRO[T](archId);
            prog();
          }
        }
        def iterTuplesRW(archId) = {
          resume { { prog } =>
            with do iterRW[T](archId);
            prog();
          }
        }
        def addComponentTuple(archId, value) = {
          resume(
            do addComponent(archId, value)
          )
        }
        def removeSwapComponentTuple(archId, index) = {
          resume(
            do removeSwapComponent[T](archId, index)
          )
        }
      }
    } with Component[Option[T]] {
      def getQueryId() = {
        resume(None())
      }
      def iterRO(archId) = {
        resume { { prog } =>
          try {
            with do iterRO[T](archId);
            try {
              prog();
            } with read[Option[T]] {
              resume {
                Some(do read())
              }
            }
          } with invalidArchID {
            try {
              prog();
            } with read[Option[T]] {
              resume {
                None()
              }
            }
          }
        }
      }
      def iterRW(archId) = {
        resume { { prog } =>
          try {
            with do iterRW[T](archId);
            try {
              prog();
            } with read[Option[T]] {
              resume{
                Some(do read())
              }
            } with emit[Option[T]] { value =>
              value match {
                case Some(v) => do emit(v)
                case _ => ()
              }
              resume(())
            }
          } with invalidArchID {
            try {
              prog();
            } with read[Option[T]] {
              resume{
                None()
              }
            } with emit[Option[T]] { _ =>
              resume(())
            }
          }
        }
      }
      def addComponent(_, _) = {
        panic("Cannot addComponent for Option Component!");
      }
      def removeSwapComponent(_, _) = {
        panic("Cannot removeSwapComponent for Option Component!");
      }
      def getComponent(_, _) = {
        panic("Cannot getComponent for Option Component!");
      }
      def setComponent(_, _, _) = {
        panic("Cannot setComponent for Option Component!");
      }
    }
  } with Component[T] {
    def getQueryId() = {
      resume(Some(componentId))
    }
    def iterRO(archId) = {
      resume { { prog } =>
        val components = componentStore.get(archId) match {
          case Some(c) => c
          case None() => {
            do invalidArchID();
            resizableArray(0)
          }
        };
        var index = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (index < components.size()) {
              val component = components.unsafeGet(index);
              index = index + 1;
              component
            } else {
              do stop()
            }
          }
        }
      }
    }
    def iterRW(archId) = {
      resume { { prog } =>
        val components = componentStore.get(archId) match {
          case Some(c) => c
          case None() => {
            do invalidArchID();
            resizableArray(0)
          }
        };
        var readIndex = 0;
        var writeIndex = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (readIndex < components.size()) {
              val component = components.unsafeGet(readIndex);
              readIndex = readIndex + 1;
              component
            } else {
              do stop()
            }
          }
        } with emit[T] { value =>
          if (writeIndex < components.size()) {
            components.unsafeSet(writeIndex, value);
            writeIndex = writeIndex + 1;
          }
          resume(())
        }
      }
    }
    def addComponent(archId, value) = {
      val components = componentStore.get(archId) match {
        case Some(components) => components
        case None() =>
          val components = resizableArray(4);
          componentStore.update(archId, components);
          components
      }
      val index = components.size();
      components.add(value);
      resume(index)
    }
    def removeSwapComponent(archId, index) = {
      val components = componentStore.unsafeGet(archId);
      val swapped = components.removeSwap(index);
      if (components.size() == 0) {
        componentStore.delete(archId);
      }
      resume(swapped)
    }
    def getComponent(archId, index) = {
      resume(
        componentStore.get(archId) match {
          case Some(components) => components.unsafeGet(index)
          case None() => panic("Archetype with id " ++ archId.show() ++ " does not contain components of type id " ++ componentId.show() ++ "!");
        }
      )
    }
    def setComponent(archId, index, value) = {
      resume(
        componentStore.get(archId) match {
          case Some(components) => components.unsafeSet(index, value);
          case None() => panic("Archetype with id " ++ archId.show() ++ " does not contain components of type id " ++ componentId.show() ++ "!");
        }
      )
    }
  }
}

def defaultComponents() { prog: => Unit / Components[Unit] }: Unit = {
  val componentIds = empty();
  try {
    prog();
  } with Components[Unit] {
    def getQueryIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        try {
          prog();
        } with read[Unit] {
          resume {
            do stop();
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        try {
          prog();
        } with read[Unit] {
          resume {
            do stop();
          }
        } with emit[Unit] { value =>
          resume(())
        }
      }
    }
    def addComponentTuple(_, _) = {
      panic("addTuple for Unit Components makes no sense!");
    }
    def removeSwapComponentTuple(_, _) = {
      panic("removeSwapTuple for Unit Components makes no sense!");
    }
  }
}

def zipComponents2[
  A,
  B
]() { prog: => Unit / { Components[(
  A,
  B
)] } }: Unit / {
  EntityManager,
  nextEntityId,
  Component[A],
  Component[B]
} = {
  var componentIds = [];
  componentIds = componentIds.addSome(do getQueryId[A]());
  componentIds = componentIds.addSome(do getQueryId[B]());
  componentIds = componentIds.sort();
  try {
    prog();
  } with Components[(
    A,
    B
  )] {
    def getQueryIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        try {
          prog();
        } with read[(
          A,
          B
        )] {
          resume {
            (
              do read[A](),
              do read[B]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        try {
          prog();
        } with read[(
          A,
          B
        )] {
          resume {
            (
              do read[A](),
              do read[B]()
            )
          }
        } with emit[(
          A,
          B
        )] { value =>
          value match {
            case (
              a,
              b
            ) =>
              do emit(a);
              do emit(b);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      resume(
        do removeSwapComponent[B](archId, index)
      )
    }
  }
}

def zipComponents3[
  A,
  B,
  C
]() { prog: => Unit / { Components[(
  A,
  B,
  C
)] } }: Unit / {
  EntityManager,
  nextEntityId,
  Component[A],
  Component[B],
  Component[C]
} = {
  var componentIds = [];
  componentIds = componentIds.addSome(do getQueryId[A]());
  componentIds = componentIds.addSome(do getQueryId[B]());
  componentIds = componentIds.addSome(do getQueryId[C]());
  componentIds = componentIds.sort();
  try {
    prog();
  } with Components[(
    A,
    B,
    C
  )] {
    def getQueryIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C]()
            )
          }
        } with emit[(
          A,
          B,
          C
        )] { value =>
          value match {
            case (
              a,
              b,
              c
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b,
            c
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b);
            do addComponent(archId, c)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      do removeSwapComponent[B](archId, index);
      resume(
        do removeSwapComponent[C](archId, index)
      )
    }
  }
}

def zipComponents4[
  A,
  B,
  C,
  D
]() { prog: => Unit / { Components[(
  A,
  B,
  C,
  D
)] } }: Unit / {
  EntityManager,
  nextEntityId,
  Component[A],
  Component[B],
  Component[C],
  Component[D]
} = {
  var componentIds = [];
  componentIds = componentIds.addSome(do getQueryId[A]());
  componentIds = componentIds.addSome(do getQueryId[B]());
  componentIds = componentIds.addSome(do getQueryId[C]());
  componentIds = componentIds.addSome(do getQueryId[D]());
  componentIds = componentIds.sort();
  try {
    prog();
  } with Components[(
    A,
    B,
    C,
    D
  )] {
    def getQueryIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        with do iterRO[D](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        with do iterRW[D](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D]()
            )
          }
        } with emit[(
          A,
          B,
          C,
          D
        )] { value =>
          value match {
            case (
              a,
              b,
              c,
              d
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
              do emit(d);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b,
            c,
            d
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b);
            do addComponent(archId, c);
            do addComponent(archId, d)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      do removeSwapComponent[B](archId, index);
      do removeSwapComponent[C](archId, index);
      resume(
        do removeSwapComponent[D](archId, index)
      )
    }
  }
}

def zipComponents5[
  A,
  B,
  C,
  D,
  E
]() { prog: => Unit / { Components[(
  A,
  B,
  C,
  D,
  E
)] } }: Unit / {
  EntityManager,
  nextEntityId,
  Component[A],
  Component[B],
  Component[C],
  Component[D],
  Component[E]
} = {
  var componentIds = [];
  componentIds = componentIds.addSome(do getQueryId[A]());
  componentIds = componentIds.addSome(do getQueryId[B]());
  componentIds = componentIds.addSome(do getQueryId[C]());
  componentIds = componentIds.addSome(do getQueryId[D]());
  componentIds = componentIds.addSome(do getQueryId[E]());
  componentIds = componentIds.sort();
  try {
    prog();
  } with Components[(
    A,
    B,
    C,
    D,
    E
  )] {
    def getQueryIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        with do iterRO[D](archId);
        with do iterRO[E](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D,
          E
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D](),
              do read[E]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        with do iterRW[D](archId);
        with do iterRW[E](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D,
          E
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D](),
              do read[E]()
            )
          }
        } with emit[(
          A,
          B,
          C,
          D,
          E
        )] { value =>
          value match {
            case (
              a,
              b,
              c,
              d,
              e
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
              do emit(d);
              do emit(e);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b,
            c,
            d,
            e
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b);
            do addComponent(archId, c);
            do addComponent(archId, d);
            do addComponent(archId, e)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      do removeSwapComponent[B](archId, index);
      do removeSwapComponent[C](archId, index);
      do removeSwapComponent[D](archId, index);
      resume(
        do removeSwapComponent[E](archId, index)
      )
    }
  }
}

def zipComponents6[
  A,
  B,
  C,
  D,
  E,
  F
]() { prog: => Unit / { Components[(
  A,
  B,
  C,
  D,
  E,
  F
)] } }: Unit / {
  EntityManager,
  nextEntityId,
  Component[A],
  Component[B],
  Component[C],
  Component[D],
  Component[E],
  Component[F]
} = {
  var componentIds = [];
  componentIds = componentIds.addSome(do getQueryId[A]());
  componentIds = componentIds.addSome(do getQueryId[B]());
  componentIds = componentIds.addSome(do getQueryId[C]());
  componentIds = componentIds.addSome(do getQueryId[D]());
  componentIds = componentIds.addSome(do getQueryId[E]());
  componentIds = componentIds.addSome(do getQueryId[F]());
  componentIds = componentIds.sort();
  try {
    prog();
  } with Components[(
    A,
    B,
    C,
    D,
    E,
    F
  )] {
    def getQueryIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        with do iterRO[D](archId);
        with do iterRO[E](archId);
        with do iterRO[F](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D,
          E,
          F
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D](),
              do read[E](),
              do read[F]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with panicOnInvaildArchId();
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        with do iterRW[D](archId);
        with do iterRW[E](archId);
        with do iterRW[F](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D,
          E,
          F
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D](),
              do read[E](),
              do read[F]()
            )
          }
        } with emit[(
          A,
          B,
          C,
          D,
          E,
          F
        )] { value =>
          value match {
            case (
              a,
              b,
              c,
              d,
              e,
              f
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
              do emit(d);
              do emit(e);
              do emit(f);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b,
            c,
            d,
            e,
            f
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b);
            do addComponent(archId, c);
            do addComponent(archId, d);
            do addComponent(archId, e);
            do addComponent(archId, f)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      do removeSwapComponent[B](archId, index);
      do removeSwapComponent[C](archId, index);
      do removeSwapComponent[D](archId, index);
      do removeSwapComponent[E](archId, index);
      resume(
        do removeSwapComponent[F](archId, index)
      )
    }
  }
}

def createResource[T](value: T) { prog: => Unit / Resource[T] }: Unit = {
  var resourceValue = value;
  try {
    prog();
  } with Resource[T] {
    def getResource() = {
      resume(resourceValue)
    }
    def setResource(value: T) = {
      resourceValue = value;
      resume(())
    }
  }
}

def archManager() { prog: => Unit / ArchManager }: Unit = {
  val archs = resizableArray(4);
  val freeIndices = resizableArray(4);
  var hasChanged = false;
  var updateQueries = resizableArray(4);
  def addArch(componentIds: List[Int]) = {
    hasChanged = true;
    val arch = Arch(componentIds, resizableArray(4));
    // TODO: Temporary check, while the ResizableArray bounds check is broken
    if (freeIndices.size() < 1) {
      archs.add(arch)
    } else {
      with on[OutOfBounds].default {
        archs.add(arch)
      }
      val index = freeIndices.popRight();
      archs.unsafeSet(index, arch);
      index
    }
  }
  def removeArch(archId: Int) = {
    if (archId < archs.size()) {
      hasChanged = true;
      archs.unsafeSet(archId, Arch([], resizableArray(0)));
      freeIndices.add(archId);
      ()
    }
  }
  def updateFindArchs(componentIds: List[Int], withoutIds: List[Int], archIds: Ref[ResizableArray[Int]]) = {
    if (componentIds.size() > 0) {
      val newArchIds = resizableArray(4);
      archs.foreachIndex() { (archId, arch) { l } =>
        var foundAll = false;
        var withoutAll = true;
        try {
          with source[Int]() { each(componentIds) };
          var checkComponent = do read[Int]();
          arch.componentIds.foreach() { (componentId) { fl } =>
            if (componentId > checkComponent) {
              fl.break();
            }
            if (componentId == checkComponent) {
              checkComponent = do read[Int]();
            }
          }
        } with stop {
          foundAll = true;
        }
        if (foundAll) {
          try {
            with source[Int]() { each(withoutIds) };
            var checkComponent = do read[Int]();
            arch.componentIds.foreach() { (componentId) { fl } =>
              while (componentId > checkComponent) {
                checkComponent = do read[Int]();
              }
              if (componentId == checkComponent) {
                withoutAll = false;
                fl.break();
              }
            }
          } with stop {
            ()
          }
        }
        if (foundAll && withoutAll) {
          newArchIds.add(archId);
          ()
        }
      }
      archIds.set(newArchIds);
    }
  }
  try {
    prog();
  } with ArchManager {
    def addUpdateQuery(componentIds, withoutIds, archIds) = {
      updateQueries.add((componentIds, withoutIds, archIds));
      resume(())
    }
    def updateQueries() = {
      if (hasChanged) {
        updateQueries.foreach() { value =>
          value match {
            case (componentIds, withoutIds, archIds) => {
              updateFindArchs(componentIds, withoutIds, archIds);
            }
          }
        }
        hasChanged = false;
      }
      resume(())
    }
    def iterEntitiesRO(archId) = {
      resume { { prog } =>
        val entities = archs.unsafeGet(archId).entities;
        var index = 0;
        try {
          prog();
        } with read[Entity] {
          resume {
            if (index < entities.size()) {
              val entity = entities.unsafeGet(index);
              index = index + 1;
              entity
            } else {
              do stop()
            }
          }
        }
      }
    }
    def addEntity(componentIds, entity) = {
      var archId = None();
      archs.foreachIndex() { (id, arch) { l } =>
        if (arch.componentIds.size() != componentIds.size()) {
          l.continue();
        }
        try {
          with source[Int]() { each(componentIds) };
          arch.componentIds.foreach() { componentId =>
            if (componentId != do read[Int]()) {
              l.continue();
            }
          }
        } with stop {
          ()
        }
        archId = Some(id);
        l.break();
      }
      val id = archId match {
        case None() => addArch(componentIds)
        case Some(id) => id
      }
      archs.unsafeGet(id).entities.add(entity);
      resume(id)
    }
    def removeSwapEntity(archId, index) = {
      val entities = archs.unsafeGet(archId).entities;
      val swapped = entities.removeSwap(index);
      if (entities.size() == 0) {
        removeArch(archId);
      }
      resume(swapped)
    }
    def getEntity(archId, index) = {
      resume(archs.unsafeGet(archId).entities.unsafeGet(index))
    }
  }
}

def entityIdManager() { prog: => Unit / nextEntityId }: Unit = {
  var lastEntityId = 0;
  try {
    prog();
  } with nextEntityId {
    lastEntityId = lastEntityId + 1;
    resume(lastEntityId)
  }
}

def entityManager() { prog: => Unit / EntityManager }: Unit / { ArchManager, nextEntityId } = {
  var entityDatas: Map[Entity, EntityData] = emptyMap();
  def setReservedEntity[T](entity: Entity, components: T) = {
    val archId = do addEntity(do getQueryIds[T](), entity);
    val componentIndex = do addComponentTuple(archId, components);
    val entityData = EntityData(archId, componentIndex);
    entityDatas.update(entity, entityData);
  }
  try {
    prog();
  } with EntityManager {
    def createEntity[T](components) = {
      resume {
        val entity = Entity(do nextEntityId());
        setReservedEntity(entity, components);
        entity
      }
    }
    def destroyEntity[T](entity) = {
      resume {
        entityDatas.get(entity) match {
          case Some(entityData) =>
            entityDatas.delete(entity);
            do removeSwapComponentTuple[T](entityData.archId, entityData.componentIndex) match {
              case Some(swapped) =>
                val swappedEntity = do getEntity(entityData.archId, swapped);
                entityDatas.update(swappedEntity, entityData);
              case None() => ()
            }
            do removeSwapEntity(entityData.archId, entityData.componentIndex);
            ()
          case None() => println("Trying to remove nonexistent Entity with id " ++ entity.id.show() ++ "!");
        }
        ()
      }
    }
    def getComponent[T](entity) = {
      resume {
        val (archId, componentIndex) = entityDatas.get(entity) match {
          case Some(EntityData(archId, componentIndex)) => (archId, componentIndex)
          case None() => panic("Trying to get component of nonexistent Entity with id " ++ entity.id.show() ++ "! Maybe it's in a deferred modification and not yet existent?")
        };
        do getComponent[T](archId, componentIndex)
      }
    }
    def setComponent[T](entity, value) = {
      resume {
        val (archId, componentIndex) = entityDatas.get(entity) match {
          case Some(EntityData(archId, componentIndex)) => (archId, componentIndex)
          case None() => panic("Trying to get component of nonexistent Entity with id " ++ entity.id.show() ++ "! Maybe it's in a deferred modification and not yet existent?")
        };
        do setComponent[T](archId, componentIndex, value);
      }
    }
    def hasEntity(entity) = {
      resume(entityDatas.get(entity).isDefined())
    }
    def setReservedEntity[T](entity, components) = {
      resume {
        setReservedEntity(entity, components);
      }
    }
  }
}

def systemEntityManager() { prog: => Unit / EntityManager }: Unit / { nextEntityId, EntityManager } = {
  try {
    prog();
  } with EntityManager {
    def createEntity[T](components) = {
      val entity = Entity(do nextEntityId());
      resume {
        (entity)
      }
      try {
        resume {
          do setReservedEntity(entity, components);
          do stop();
        }
      } with stop {
        ()
      }
    }
    def setReservedEntity[T](entity, components) = {
      panic("Cannot manually setReservedEntity!");
    }
    def destroyEntity[T](entity) = {
      resume {
        ()
      }
      try {
        resume {
          do destroyEntity[T](entity);
          do stop();
        }
      } with stop {
        ()
      }
    }
    def getComponent[T](entity) = {
      resume {
        if (do hasEntity(entity)) {
          do getComponent(entity)
        } else {
          panic("Cannot get component of to-be-created entity inside a system!");
        }
      }
    }
    def setComponent[T](entity, value) = {
      if (do hasEntity(entity)) {
        resume {
          do setComponent(entity, value);
        }
      } else {
        resume {
          ()
        }
        try {
          resume {
            do setComponent(entity, value);
            do stop();
          }
        } with stop {
          ()
        }
      }
    }
    def hasEntity(entity) = {
      resume(
        do hasEntity(entity)
      )
    }
  }
}

def query[T, With, Without]()
{ prog: () { query: Query[T, With, Without] } => Unit }: Unit / {
  ArchManager, Components[T], Components[With], Components[Without]
} = {
  val componentIds = dedupMergeInt(do getQueryIds[T](), do getQueryIds[With]()); 
  val withoutIds = do getQueryIds[Without]();
  val archIds = ref(resizableArray(0));
  do addUpdateQuery(componentIds, withoutIds, archIds);
  try {
    prog() { query };
  } with query: Query[T, With, Without] {
    def foreachRO() = {
      resume { { action } =>
        archIds.get().foreach() { archId =>
          try {
            with do iterEntitiesRO(archId);
            with do iterTuplesRO[T](archId);
            loop {
              action(do read(), do read());
            }
          } with stop {
            ()
          }
        }
      }
    }
    def foreachRW() = {
      resume { { action } =>
        archIds.get().foreach() { archId =>
          try {
            with do iterEntitiesRO(archId);
            with do iterTuplesRW[T](archId);
            loop {
              val entity = do read[Entity]();
              val value = do read[T]();
              do emit(action(entity, value));
            }
          } with stop {
            ()
          }
        }
      }
    }
  }
}

def defaultSystem() { prog: => Unit / System } = {
  try {
    prog();
  } with System {
    def step() = {
      resume {
        ()
      }
    }
  }
}

def addSystem[T, With, Without]()
{ body: () { query: Query[T, With, Without] } => Unit / EntityManager }
{ prog: => Unit / System }: Unit / {
  ArchManager, System, Components[T], Components[With], Components[Without]
} = {
  with def q = query[T, With, Without]();
  try {
    prog();
  } with System {
    def step() = {
      resume {
        do step();
        body() { q };
      }
    }
  }
}