import resizable_array
import mutable/map

import game_engine_lib/core

interface TypeManager {
  def getNextTypeId(): Int
}

def defaultTypeManager() { prog: => Unit / TypeManager }: Unit / {} = {
  var lastTypeId = 0;
  try {
    prog();
  } with TypeManager {
    def getNextTypeId() = {
      lastTypeId = lastTypeId + 1;
      resume(lastTypeId)
    }
  }
}

interface ComponentStore[T] {
  def getTypeId(): Int
  def get(archId: Int, index: Int): T
  def set(archId: Int, index: Int, value: T): Unit
  def push(archId: Int, value: T): Int
  def swapRemove(archId: Int, index: Int): Option[Int]
  def iterate(archId: Int): IterResizableArray[T]
  def getArchIdToIndexMap(): Map[Int, Int]
}

def createComponentStore[T] { prog: => Unit / ComponentStore[T] }: Unit / TypeManager = {
  val typeId = do getNextTypeId();
  var archVectors = resizableArray[ResizableArray[T]](4);
  var archIdToIndexMap = emptyMap();
  var archIndexToIdMap = emptyMap();
  try {
    prog();
  } with ComponentStore[T] {
    def getTypeId() = {
      resume(typeId)
    }
    def get(archId: Int, index: Int) = {
      resume(archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).unsafeGet(index))
    }
    def set(archId: Int, index: Int, value: T) = {
      archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).unsafeSet(index, value);
      resume(())
    }
    def push(archId: Int, value: T) = {
      resume(
        archIdToIndexMap.get(archId) match {        
          case Some(archIndex) => archVectors.unsafeGet(archIndex).add(value)
          case None() => {
            val newArchIndex = archVectors.size();
            val newArchVector = resizableArray(4);
            newArchVector.add(value);
            archVectors.add(newArchVector);
            archIdToIndexMap.update(archId, newArchIndex);
            archIndexToIdMap.update(newArchIndex, archId)
            0
          }
        }
      )
    }
    def swapRemove(archId: Int, index: Int) = {
      with report[OutOfBounds]();
      val archIndex = archIdToIndexMap.unsafeGet(archId);
      val arr = archVectors.unsafeGet(archIndex);
      val swapIndex = arr.removeSwap(index);
      if (arr.size() == 0) {
        archVectors.removeSwap(archIndex) match {
          case Some(i) => {
            val swappedArchId = archIndexToIdMap.unsafeGet(i);
            archIndexToIdMap.update(archIndex, swappedArchId);
            archIdToIndexMap.update(swappedArchId, archIndex);
          }
          case None() => ()
        }
        archIndexToIdMap.delete(archVectors.size());
        archIdToIndexMap.delete(archId);
      }
      resume(swapIndex)
    }
    def iterate(archId: Int) = {
      resume(archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).iterate())
    }
    def getArchIdToIndexMap() = {
      resume(archIdToIndexMap)
    }
  }
}

interface Resource[T] {
  def getTypeId(): Int
  def get(): T
  def set(value: T): Unit
}

def createResource[T](value: T) { prog: => Unit / Resource[T] }: Unit / TypeManager = {
  val typeId = do getNextTypeId();
  var res = value;
  try {
    prog();
  } with Resource[T] {
    def getTypeId() = {
      resume(typeId)
    }
    def get() = {
      resume(res)
    }
    def set(value: T) = {
      res = value;
      resume(())
    }
  }
}

def getArchIterators[
  A
](): (
  IterChainResizableArray[A]
) / {
  ComponentStore[A]
} = {
  val chainsA = resizableArray();
  do getArchIdToIndexMap[A]().keys().foreach() { archId =>
    chainsA.add(do iterate[A](archId));
    ()
  };
  (
    chainsA.iterate()
  )
}

def getArchIterators[
  A,
  B
](): (
  IterChainResizableArray[A],
  IterChainResizableArray[B]
) / {
  ComponentStore[A],
  ComponentStore[B]
} = {
  val chainsA = resizableArray();
  val chainsB = resizableArray();
  val archIdToIndexMapB = do getArchIdToIndexMap[B]();
  do getArchIdToIndexMap[A]().keys().foreach() { archId =>
    if (
      archIdToIndexMapB.get(archId).isDefined()
    ) {
      chainsA.add(do iterate[A](archId));
      chainsB.add(do iterate[B](archId));
      ()
    }
  };
  (
    chainsA.iterate(),
    chainsB.iterate()
  )
}

def getArchIterators[
  A,
  B,
  C
](): (
  IterChainResizableArray[A],
  IterChainResizableArray[B],
  IterChainResizableArray[C]
) / {
  ComponentStore[A],
  ComponentStore[B],
  ComponentStore[C]
} = {
  val chainsA = resizableArray();
  val chainsB = resizableArray();
  val chainsC = resizableArray();
  val archIdToIndexMapB = do getArchIdToIndexMap[B]();
  val archIdToIndexMapC = do getArchIdToIndexMap[C]();
  do getArchIdToIndexMap[A]().keys().foreach() { archId =>
    if (
      archIdToIndexMapB.get(archId).isDefined()
      && archIdToIndexMapC.get(archId).isDefined()
    ) {
      chainsA.add(do iterate[A](archId));
      chainsB.add(do iterate[B](archId));
      chainsC.add(do iterate[C](archId));
      ()
    }
  };
  (
    chainsA.iterate(),
    chainsB.iterate(),
    chainsC.iterate()
  )
}

def getArchIterators[
  A,
  B,
  C,
  D
](): (
  IterChainResizableArray[A],
  IterChainResizableArray[B],
  IterChainResizableArray[C],
  IterChainResizableArray[D]
) / {
  ComponentStore[A],
  ComponentStore[B],
  ComponentStore[C],
  ComponentStore[D]
} = {
  val chainsA = resizableArray();
  val chainsB = resizableArray();
  val chainsC = resizableArray();
  val chainsD = resizableArray();
  val archIdToIndexMapB = do getArchIdToIndexMap[B]();
  val archIdToIndexMapC = do getArchIdToIndexMap[C]();
  val archIdToIndexMapD = do getArchIdToIndexMap[D]();
  do getArchIdToIndexMap[A]().keys().foreach() { archId =>
    if (
      archIdToIndexMapB.get(archId).isDefined()
      && archIdToIndexMapC.get(archId).isDefined()
      && archIdToIndexMapD.get(archId).isDefined()
    ) {
      chainsA.add(do iterate[A](archId));
      chainsB.add(do iterate[B](archId));
      chainsC.add(do iterate[C](archId));
      chainsD.add(do iterate[D](archId));
      ()
    }
  };
  (
    chainsA.iterate(),
    chainsB.iterate(),
    chainsC.iterate(),
    chainsD.iterate()
  )
}

def createSystem() { body: => Unit } = {
  fun() {
    body();
  }
}

def createSystem[
  A
]() { body: (
  IterChainResizableArray[A]
) => Unit } = {
  fun() {
    getArchIterators[
      A
    ]() match {
      case iterA => body(
        iterA
      );
    }
  }
}

def createSystem[
  A,
  B
]() { body: (
  IterChainResizableArray[A],
  IterChainResizableArray[B]
) => Unit } = {
  fun() {
    getArchIterators[
      A,
      B
    ]() match {
      case (
        iterA,
        iterB
      ) => body(
        iterA,
        iterB
      );
    }
  }
}

interface World {
  def pushBackSystem(system: => Unit at {}): Unit
  /*
  def pushBackSystem[
    A
  ]() { system: (
    IterChainResizableArray[A]
  ) => Unit }: Unit
  def pushBackSystem[
    A,
    B
  ]() { system: (
    IterChainResizableArray[A],
    IterChainResizableArray[B]
  ) => Unit }: Unit
  */
  def step(): Unit
  def run(): Unit
}

def defaultWorld() { prog: => Unit / World }: Unit / {} = {
  var systems = fun() { () };
  def stepWorld() = {
    systems()
  }
  try {
    prog();
  } with World {
    def pushBackSystem(system) = {
      systems = fun() {
        systems();
        system();
      }
      resume(())
    }
    def step() = {
      stepWorld();
      resume(())
    }
    def run() = {
      loop { { l } =>
        stepWorld();
      }
    }
  }
}