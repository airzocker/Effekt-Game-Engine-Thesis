module ecs

import array
import resizable_array
import mutable/map
import io
import io/time
import stream

import game_engine_lib/core

record Entity(id: Int, index: Int)

record EntityData(archId: Int, entityIndex: Int)

record Arch(componentIndices: Map[Int, ResizableArray[Int]], entities: ResizableArray[Entity])

// Resource to signal world loop exit
record RunWorld(run: Bool)

type ComponentOp {
  Remove[T](componentStore: Ref[OptionArray[T]])
  Copy[T](componentStore: Ref[OptionArray[T]])
}

interface ECSException {
  def invalidEntity(entity: Entity): Nothing
  def invalidComponent(entity: Entity, componentId: Int): Nothing
}

interface ComponentManager {
  def internalRegisterComponentStore[T](componentStore: Ref[OptionArray[T]]): Int
  def internalRemoveComponent(componentId: Int, componentIndex: Int): Unit
  def internalCopyComponent(componentId: Int, fromComponentIndex: Int, toComponentIndex: Int): Unit
}

interface Component[T] {
  def getComponentId(): Int
  def internalAddComponent(value: T): Int
  def internalGetComponent(index: Int): T
  def internalSetComponent(index: Int, value: T): Unit
}

interface Resource[T] {
  def getResource(): T
  def setResource(value: T): Unit
}

interface ArchManager {
  def internalHasComponent(archId: Int, componentId: Int): Bool
  def internalAddEntity(entity: Entity): EntityData
  def internalRemoveSwapEntity(entityData: EntityData): Option[Entity]
  def internalGetComponent[T](entityData: EntityData): Option[T] / Component[T]
  def internalSetComponent[T](entityData: EntityData, value: T): Option[(EntityData, Option[Entity])] / Component[T]
  def internalAddExistingComponent(entityData: EntityData, componentId: Int, componentIndex: Int): (EntityData, Option[Entity])
  def internalRemoveComponent(entityData: EntityData, componentId: Int): (EntityData, Option[Entity])
  def internalIterEntities(archIds: ResizableArray[Int], iterAll: Bool) { prog: => Unit / read[Entity] }: Unit / stop
  def internalIterRO[T](archIds: ResizableArray[Int]) { prog: => Unit / read[T] }: Unit / { Component[T], stop }
  def internalIterRW[T](archIds: ResizableArray[Int]) { prog: => Unit / { read[T], emit[T] } }: Unit / { Component[T], stop }
  def internalIterOptRO[T](archIds: ResizableArray[Int], iterAll: Bool) { prog: => Unit / read[Option[T]] }: Unit / { Component[T], stop }
  def internalIterOptRW[T](archIds: ResizableArray[Int], iterAll: Bool) { prog: => Unit / { read[Option[T]], emit[Option[T]] } }: Unit / { Component[T], stop }
  def internalGetQueryArchIds(withIds: Map[Int, Unit], withoutIds: Map[Int, Unit], lastChangeVersion: Int): Option[(ResizableArray[Int], Int)]
}

interface EntityIdManager {
  def internalNextEntityId(): Int
  def invalidEntityId(): Int
}

interface EntityManager {
  def hasEntity(entity: Entity): Bool
  def hasComponent[T](entity: Entity): Bool / { Component[T], ECSException }
  def getEntityData(entity: Entity): EntityData / ECSException
  def createEntity(): Entity
  def destroyEntity(entity: Entity): Unit / ECSException
  def removeComponent[T](entity: Entity): Unit / { Component[T], ECSException }
  def getComponent[T](entity: Entity): T / { Component[T], ECSException }
  def setComponent[T](entity: Entity, value: T): Unit / { Component[T], ECSException }
  def internalGetEntityDatas(): OptionArray[(Entity, EntityData)]
}

interface Query[T, With, Without] {
  def foreachRO() { action: (Entity, T) => Unit }: Unit
  def foreachRW() { action: (Entity, T) => T }: Unit
  def iterRO() { prog: => Unit / read[T] }: Unit / stop
  def iterRW() { prog: => Unit / { read[T], emit[T] } }: Unit / stop
  def internalGetWithWithoutIds(): (Map[Int, Unit], Map[Int, Unit])
}

interface QueryManager {
  def query[T]() { prog: => Unit / Query[T, Unit, Unit] }: Unit / Component[T]
  def optQuery[T]() { prog: => Unit / Query[Option[T], Unit, Unit] }: Unit / Component[T]
  def allQuery() { prog: => Unit / Query[Unit, Unit, Unit] }: Unit
}

interface System {
  def internalStep(): Unit / EntityManager
}

interface World {
  def stepWorld(): Unit / System
  def runWorld(): Unit / System
}

def componentManager() { prog: => Unit / ComponentManager }: Unit = {
  var removeOps = resizableArray(4);
  var copyOps = resizableArray(4);
  try {
    prog();
  } with ComponentManager {
    def internalRegisterComponentStore[T](componentStore) = {
      removeOps.add(Remove(componentStore));
      copyOps.add(Copy(componentStore));
      resume(removeOps.size() - 1)
    }
    def internalRemoveComponent(componentId, componentIndex) = {
      removeOps.unsafeGet(componentId) match {
        case Remove(componentStore) => componentStore.get().remove(componentIndex)
        case _ => ()
      }
      resume(())
    }
    def internalCopyComponent(componentId, fromComponentIndex, toComponentIndex) = {
      copyOps.unsafeGet(componentId) match {
        case Copy(componentStore) => {
          val cs = componentStore.get();
          cs.unsafeSet(toComponentIndex, cs.unsafeGet(fromComponentIndex))
        }
        case _ => ()
      }
      resume(())
    }
  }
}

def component[T]() { prog: => Unit / Component[T] }: Unit / ComponentManager = {
  val componentStore = ref(optionArray(4));
  val componentId = do internalRegisterComponentStore(componentStore);
  try {
    prog();
  } with Component[T] {
    def getComponentId() = {
      resume((componentId))
    }
    def internalAddComponent(value) = {
      resume(componentStore.get().add(value))
    }
    def internalGetComponent(index) = {
      val value = componentStore.get().unsafeGet(index);
      resume(value)
    }
    def internalSetComponent(index, value) = {
      componentStore.get().unsafeSet(index, value);
      resume(())
    }
  }
}

def createResource[T](value: T) { prog: => Unit / Resource[T] }: Unit = {
  var resourceValue = value;
  try {
    prog();
  } with Resource[T] {
    def getResource() = {
      resume(resourceValue)
    }
    def setResource(value) = {
      resourceValue = value;
      resume(())
    }
  }
}

def archManager() { prog: => Unit / ArchManager }: Unit / ComponentManager = {
  val archs = optionArray(4);
  archs.add(Arch(emptyMap(), resizableArray(4)));
  var changeVersion = 1;
  def addArch(arch: Arch): Int = {
    changeVersion = changeVersion + 1;
    archs.add(arch)
  }
  def removeArch(archId: Int) = {
    changeVersion = changeVersion + 1;
    archs.remove(archId);
  }
  def getComponentIndices(archId: Int, componentId: Int): Option[ResizableArray[Int]] = {
    archs.unsafeGet(archId).componentIndices.get(componentId)
  }
  def getMatchingArchId(componentIds: Array[Int]): Option[Int] = {
    var matching = None();
    archs.arr.foreachIndex() { (i, archOpt) { l } =>
      archOpt.map() { arch =>
        if (arch.componentIndices.containsOnlyAll(componentIds)) {
          matching = Some(i);
          l.break();
        }
        ()
      }
      ()
    };
    matching
  }
  def removeSwapEntityIndices(arch: Arch, entityIndex: Int): Option[Entity] = {
    val swapped = arch.entities.removeSwap(entityIndex).map() { index =>
      arch.entities.unsafeGet(index)
    };
    arch.componentIndices.values().foreach() { indices =>
      indices.removeSwap(entityIndex);
      ()
    };
    swapped
  }
  def addExistingComponent(entityData: EntityData, componentId: Int, componentIndex: Int): (EntityData, Option[Entity]) = {
    val oldArch = archs.unsafeGet(entityData.archId);
    val newCompIndices = emptyMap();
    var sameArch = false;
    oldArch.componentIndices.keys().foreach() { (compId) { l } =>
      if (compId == componentId) {
        sameArch = true;
        l.break();
      }
      newCompIndices.update(compId, resizableArray(0));
    };
    newCompIndices.update(componentId, resizableArray(0));
    if (sameArch) {
      val oldComponentIndex = oldArch.componentIndices.unsafeGet(componentId).unsafeGet(entityData.entityIndex);
      do internalCopyComponent(componentId, componentIndex, oldComponentIndex);
      do internalRemoveComponent(componentId, componentIndex);
      (
        entityData,
        None()
      )
    } else {
      val newArchId = getMatchingArchId(newCompIndices.keys()).getOrElse() {
        addArch(Arch(newCompIndices, resizableArray(4)))
      };
      val newArch = archs.unsafeGet(newArchId);
      val newEntityIndex = newArch.entities.add(oldArch.entities.unsafeGet(entityData.entityIndex));
      oldArch.componentIndices.keys().foreach() { compId =>
        newArch.componentIndices.unsafeGet(compId).add(oldArch.componentIndices.unsafeGet(compId).unsafeGet(entityData.entityIndex));
        ()
      };
      newArch.componentIndices.unsafeGet(componentId).add(componentIndex);
      val swapped = oldArch.removeSwapEntityIndices(entityData.entityIndex);
      if (entityData.archId > 0 && oldArch.entities.size() == 0) {
        removeArch(entityData.archId);
      }
      (
        EntityData(newArchId, newEntityIndex),
        swapped
      )
    }
  }
  try {
    prog();
  } with ArchManager {
    def internalHasComponent(archId, componentId) = {
      resume(archs.unsafeGet(archId).componentIndices.get(componentId).isDefined())
    }
    def internalAddEntity(entity) = {
      resume(EntityData(0, archs.unsafeGet(0).entities.add(entity)))
    }
    def internalRemoveSwapEntity(entityData) = {
      val arch = archs.unsafeGet(entityData.archId);
      arch.componentIndices.keys().foreach() { compId =>
        val compIndex = arch.componentIndices.unsafeGet(compId).unsafeGet(entityData.entityIndex);
        do internalRemoveComponent(compId, compIndex);
      };
      val swapped = arch.removeSwapEntityIndices(entityData.entityIndex);
      if (entityData.archId > 0 && arch.entities.size() == 0) {
        removeArch(entityData.archId);
      }
      resume(swapped)
    }
    def internalGetComponent[T](entityData) = {
      resume {
        val compId = do getComponentId[T]();
        archs.unsafeGet(entityData.archId).componentIndices.get(compId).map() { compIndices =>
          val compIndex = compIndices.unsafeGet(entityData.entityIndex);
          do internalGetComponent(compIndex)
        }
      }
    }
    def internalSetComponent[T](entityData, value) = {
      resume {
        val compId = do getComponentId[T]();
        archs.unsafeGet(entityData.archId).componentIndices.get(compId) match {
          case Some(compIndices) => {
            val compIndex = compIndices.unsafeGet(entityData.entityIndex);
            do internalSetComponent(compIndex, value);
            None()
          }
          case None() => Some(addExistingComponent(entityData, compId, do internalAddComponent(value)));
        }
      }
    }
    def internalAddExistingComponent(entityData, componentId, componentIndex) = {
      resume(addExistingComponent(entityData, componentId, componentIndex))
    }
    def internalRemoveComponent(entityData, componentId) = {
      val oldArch = archs.unsafeGet(entityData.archId);
      val newCompIndices = emptyMap();
      var sameArch = true;
      oldArch.componentIndices.keys().foreach() { compId =>
        if (compId == componentId) {
          sameArch = false;
        } else {
          newCompIndices.update(compId, resizableArray(0));
        }
      };
      if (sameArch) {
        resume((
          entityData,
          None()
        ))
      } else {
        val newCompIds = newCompIndices.keys();
        val newArchId = getMatchingArchId(newCompIds).getOrElse() {
          addArch(Arch(newCompIndices, resizableArray(4)))
        };
        val newArch = archs.unsafeGet(newArchId);
        val newEntityIndex = newArch.entities.add(oldArch.entities.unsafeGet(entityData.entityIndex));
        newCompIds.foreach() { compId =>
          newArch.componentIndices.unsafeGet(compId).add(oldArch.componentIndices.unsafeGet(compId).unsafeGet(entityData.entityIndex));
          ()
        };
        do internalRemoveComponent(componentId, oldArch.componentIndices.unsafeGet(componentId).unsafeGet(entityData.entityIndex));
        val swapped = oldArch.removeSwapEntityIndices(entityData.entityIndex);
        if (entityData.archId > 0 && oldArch.entities.size() == 0) {
          removeArch(entityData.archId);
        }
        resume((
          EntityData(newArchId, newEntityIndex),
          swapped
        ))
      }
    }
    def internalIterEntities(archIds, iterAll) = {
      resume { { prog } =>
        if (archIds.size() == 0 && not(iterAll)) {
          try {
            prog();
          } with read[Entity] {
            do stop()
          }
        }
        var archIndex = 0;
        var entities = if (iterAll) {
          archs.unsafeGet(archIndex).entities
        } else {
          archs.unsafeGet(archIds.unsafeGet(archIndex)).entities
        };
        var index = 0;
        try {
          prog();
        } with read[Entity] {
          resume {
            while (index >= entities.size()) {
              index = 0;
              if (iterAll) {
                loop { { l } =>
                  archIndex = archIndex + 1;
                  if (archIndex >= archs.size()) {
                    do stop()
                  } else {
                    entities = archs.get(archIndex).map() { arch =>
                      arch.entities
                    }.getOrElse() {
                      l.continue();
                      panic("");
                    };
                    l.break();
                  }
                }
              } else {
                archIndex = archIndex + 1;
                if (archIndex >= archIds.size()) {
                  do stop()
                } else {
                  entities = archs.unsafeGet(archIds.unsafeGet(archIndex)).entities;
                }
              }
            }
            index = index + 1;
            entities.unsafeGet(index - 1)
          }
        }
      }
    }
    def internalIterRO[T](archIds) = {
      resume { { prog } =>
        if (archIds.size() == 0) {
          try {
            prog();
          } with read[T] {
            do stop()
          }
        }
        val compId = do getComponentId[T]();
        var archIndex = 0;
        var componentIndices = getComponentIndices(archIds.unsafeGet(archIndex), compId).unsafeValue();
        var index = 0;
        try {
          prog();
        } with read[T] {
          resume {
            while (index >= componentIndices.size()) {
              index = 0;
              archIndex = archIndex + 1;
              if (archIndex >= archIds.size()) {
                do stop()
              } else {
                componentIndices = getComponentIndices(archIds.unsafeGet(archIndex), compId).unsafeValue();
              }             
            }
            index = index + 1;
            do internalGetComponent(componentIndices.unsafeGet(index - 1))
          }
        }
      }
    }
    def internalIterRW[T](archIds) = {
      resume { { prog } =>
        if (archIds.size() == 0) {
          try {
            prog();
          } with read[T] {
            do stop()
          } with emit[T] { _ =>
            do stop()
          }
        }
        val compId = do getComponentId[T]();
        var archIndex = 0;
        var componentIndices = getComponentIndices(archIds.unsafeGet(archIndex), compId).unsafeValue();
        var index = 0;
        try {
          prog();
        } with read[T] {
          resume {
            while (index >= componentIndices.size()) {
              index = 0;
              archIndex = archIndex + 1;
              if (archIndex >= archIds.size()) {
                do stop()
              } else {
                componentIndices = getComponentIndices(archIds.unsafeGet(archIndex), compId).unsafeValue();
              }             
            }
            index = index + 1;
            do internalGetComponent(componentIndices.unsafeGet(index - 1))
          }
        } with emit[T] { value =>
          do internalSetComponent(componentIndices.unsafeGet(index - 1), value)
          resume(())
        }
      }
    }
    def internalIterOptRO[T](archIds, iterAll) = {
      resume { { prog } =>
        if (archIds.size() == 0 && not(iterAll)) {
          try {
            prog();
          } with read[Option[T]] {
            do stop()
          }
        }
        val compId = do getComponentId[T]();
        var archIndex = 0;
        var componentIndices = None();
        var entityCount = 0;
        if (iterAll) {
          (getComponentIndices(archIndex, compId), archs.unsafeGet(archIndex).entities.size())
        } else {
          (getComponentIndices(archIds.unsafeGet(archIndex), compId), archs.unsafeGet(archIndex).entities.size())
        } match {
          case (ci, ec) => {
            componentIndices = ci;
            entityCount = ec;
          }
        };
        var index = 0;
        try {
          prog();
        } with read[Option[T]] {
          resume {
            while (index >= entityCount) {
              index = 0;
              if (iterAll) {
                loop { { l } =>
                  archIndex = archIndex + 1;
                  if (archIndex >= archs.size()) {
                    do stop()
                  } else {
                    if (archs.get(archIndex).isDefined()) {
                      if (iterAll) {
                        (getComponentIndices(archIndex, compId), archs.unsafeGet(archIndex).entities.size())
                      } else {
                        (getComponentIndices(archIds.unsafeGet(archIndex), compId), archs.unsafeGet(archIndex).entities.size())
                      } match {
                        case (ci, ec) => {
                          componentIndices = ci;
                          entityCount = ec;
                        }
                      };
                    } else {
                      l.continue();
                    }
                    l.break();
                  }
                }
              } else {
                archIndex = archIndex + 1;
                if (archIndex >= archIds.size()) {
                  do stop()
                } else {
                  if (iterAll) {
                    (getComponentIndices(archIndex, compId), archs.unsafeGet(archIndex).entities.size())
                  } else {
                    (getComponentIndices(archIds.unsafeGet(archIndex), compId), archs.unsafeGet(archIndex).entities.size())
                  } match {
                    case (ci, ec) => {
                      componentIndices = ci;
                      entityCount = ec;
                    }
                  };
                }
              }
            }
            index = index + 1;
            componentIndices.map() { compIndices =>
              do internalGetComponent(compIndices.unsafeGet(index - 1))
            }
          }
        }
      }
    }
    def internalIterOptRW[T](archIds, iterAll) = {
      resume { { prog } =>
        if (archIds.size() == 0 && not(iterAll)) {
          try {
            prog();
          } with read[Option[T]] {
            do stop()
          } with emit[Option[T]] { _ =>
            do stop()
          }
        }
        val compId = do getComponentId[T]();
        var archIndex = 0;
        var componentIndices = None();
        var entityCount = 0;
        if (iterAll) {
          (getComponentIndices(archIndex, compId), archs.unsafeGet(archIndex).entities.size())
        } else {
          (getComponentIndices(archIds.unsafeGet(archIndex), compId), archs.unsafeGet(archIndex).entities.size())
        } match {
          case (ci, ec) => {
            componentIndices = ci;
            entityCount = ec;
          }
        };
        var index = 0;
        try {
          prog();
        } with read[Option[T]] {
          resume {
            while (index >= entityCount) {
              index = 0;
              if (iterAll) {
                loop { { l } =>
                  archIndex = archIndex + 1;
                  if (archIndex >= archs.size()) {
                    do stop()
                  } else {
                    if (archs.get(archIndex).isDefined()) {
                      if (iterAll) {
                        (getComponentIndices(archIndex, compId), archs.unsafeGet(archIndex).entities.size())
                      } else {
                        (getComponentIndices(archIds.unsafeGet(archIndex), compId), archs.unsafeGet(archIndex).entities.size())
                      } match {
                        case (ci, ec) => {
                          componentIndices = ci;
                          entityCount = ec;
                        }
                      };
                    } else {
                      l.continue();
                    }
                    l.break();
                  }
                }
              } else {
                archIndex = archIndex + 1;
                if (archIndex >= archIds.size()) {
                  do stop()
                } else {
                  if (iterAll) {
                    (getComponentIndices(archIndex, compId), archs.unsafeGet(archIndex).entities.size())
                  } else {
                    (getComponentIndices(archIds.unsafeGet(archIndex), compId), archs.unsafeGet(archIndex).entities.size())
                  } match {
                    case (ci, ec) => {
                      componentIndices = ci;
                      entityCount = ec;
                    }
                  };
                }
              }
            }
            index = index + 1;
            componentIndices.map() { compIndices =>
              do internalGetComponent(compIndices.unsafeGet(index - 1))
            }
          }
        } with emit[Option[T]] { value =>
          (componentIndices, value) match {
            case (Some(compIndices), Some(value)) => do internalSetComponent(compIndices.unsafeGet(index - 1), value)
            case _ => ()
          }
          resume(())
        }

      }      
    }
    def internalGetQueryArchIds(withIds, withoutIds, lastChangeVersion) = {
      var result = None();
      if (lastChangeVersion < changeVersion) {
        val matching = resizableArray(4);
        archs.arr.foreachIndex() { (i, archOpt) =>
          archOpt.map() { arch =>
            val archCompIds = arch.componentIndices;
            if (archCompIds.containsAll(withIds.keys()) && archCompIds.containsNone(withoutIds.keys())) {
              matching.add(i);
              ()
            }
          };
          ()
        };
        result = Some((matching, changeVersion));
      }
      resume(result)
    }
  }
}

def entityIdManager() { prog: => Unit / EntityIdManager }: Unit = {
  var lastEntityId = 0;
  try {
    prog();
  } with EntityIdManager {
    def internalNextEntityId() = {
      lastEntityId = lastEntityId + 1;
      resume(lastEntityId)
    }
    def invalidEntityId() = {
      resume(0)
    }
  }
}

def entityManager() { prog: => Unit / EntityManager }: Unit / { ArchManager, EntityIdManager } = {
  var entityDatas: OptionArray[(Entity, EntityData)] = optionArray(4);
  def getEntityData(entity: Entity): EntityData / ECSException = {
    entityDatas.get(entity.index).map() { value =>
      if (entity.id == value.first.id) {
        value.second
      } else {
        do invalidEntity(entity);
      }
    }.getOrElse() {
      do invalidEntity(entity);
    }
  }
  try {
    prog();
  } with EntityManager {
    def hasEntity(entity) = {
      resume(entityDatas.get(entity.index).isDefined())
    }
    def hasComponent[T](entity) = {
      resume {
        val entityData = getEntityData(entity);
        do internalHasComponent(entityData.archId, do getComponentId[T]())
      }
    }
    def getEntityData(entity) = {
      resume {
        getEntityData(entity)
      }
    }
    def createEntity() = {
      val tempEntity = Entity(do internalNextEntityId(), 0);
      val index = entityDatas.add((tempEntity, EntityData(0, 0)));
      val entity = Entity(tempEntity.id, index);
      val entityData = do internalAddEntity(entity);
      entityDatas.unsafeSet(index, (entity, entityData));
      resume(entity)
    }
    def destroyEntity(entity) = {
      resume {
        val entityData = getEntityData(entity);
        do internalRemoveSwapEntity(entityData).map() { swappedEntity =>
          entityDatas.unsafeSet(swappedEntity.index, (swappedEntity, entityData));
        };
        entityDatas.remove(entity.index);
      }
    }
    def removeComponent[T](entity) = {
      resume {
        val compId = do getComponentId[T]();
        val entityData = getEntityData(entity);
        val (newEntityData, swapped) = do internalRemoveComponent(entityData, compId);
        entityDatas.unsafeSet(entity.index, (entity, newEntityData));
        swapped.map() { swappedEntity =>
          entityDatas.unsafeSet(swappedEntity.index, (swappedEntity, entityData));
        };
        ()
      }
    }
    def getComponent[T](entity) = {
      resume {
        val entityData = getEntityData(entity);
        (do internalGetComponent(entityData)).getOrElse() {
          do invalidComponent(entity, do getComponentId[T]());
        }
      }
    }
    def setComponent[T](entity, value) = {
      resume {
        val entityData = getEntityData(entity);
        (do internalSetComponent(entityData, value)).map() { result =>
          val (newEntityData, swapped) = result;
          entityDatas.unsafeSet(entity.index, (entity, newEntityData));
          swapped.map() { swappedEntity =>
            entityDatas.unsafeSet(swappedEntity.index, (swappedEntity, entityData));
          };
        }
        ()
      }
    }
    def internalGetEntityDatas() = {
      resume(entityDatas)
    }
  }
}

def systemEntityManager(entityDatas: OptionArray[(Entity, EntityData)]) { prog: => Unit / EntityManager }: Unit / { ArchManager, EntityIdManager, EntityManager } = {
  try {
    prog();
  } with EntityManager {
    def hasEntity(entity) = {
      resume(do hasEntity(entity))
    }
    def hasComponent[T](entity) = {
      resume{
        do hasComponent[T](entity)
      }
    }
    def getEntityData(entity) = {
      resume {
        do getEntityData(entity)
      }
    }
    def createEntity() = {
      val tempEntity = Entity(do internalNextEntityId(), 0);
      val index = entityDatas.add((Entity(do invalidEntityId(), 0), EntityData(0, 0)));
      val entity = Entity(tempEntity.id, index);
      resume(entity)
      val entityData = do internalAddEntity(entity);
      entityDatas.unsafeSet(index, (entity, entityData));
    }
    def destroyEntity(entity) = {
      resume {
        ()
      }
      try {
        resume {
          do destroyEntity(entity);
          do stop();
        }
      } with stop {
        ()
      }
    }
    def removeComponent[T](entity) = {
      var compId = 0;
      resume {
        compId = do getComponentId[T]();
      }
      try {
        resume {
          val entityData = do getEntityData(entity);
          val (newEntityData, swapped) = do internalRemoveComponent(entityData, compId);
          entityDatas.unsafeSet(entity.index, (entity, newEntityData));
          swapped.map() { swappedEntity =>
            entityDatas.unsafeSet(swappedEntity.index, (swappedEntity, entityData));
          };
          do stop();
        }
      } with stop {
        ()
      }
    }
    def getComponent[T](entity) = {
      resume {
        do getComponent(entity)
      }
    }
    def setComponent[T](entity, value) = {
      var didSet = false;
      resume {
        try {
          if (do hasComponent[T](entity)) {
            do setComponent(entity, value);
            didSet = true;
          }
        } with ECSException {
          def invalidEntity(entity) = {
            ()
          }
          def invalidComponent(entity, componentId) = {
            ()
          }
        }
      }
      if (not(didSet)) {
        try {
          resume {
            do setComponent(entity, value);
            do stop();
          }
        } with stop {
          ()
        }
      }
    }
    def internalGetEntityDatas() = {
      resume(do internalGetEntityDatas())
    }
  }
}

def system()
{ prog: => Unit / System }
{ body: => Unit / EntityManager }: Unit /
{ System, ArchManager, EntityIdManager } = {
  try {
    prog();
  } with System {
    def internalStep() = {
      resume {
          do internalStep();
          systemEntityManager(do internalGetEntityDatas()) {
            body();
          };
      }
    }
  }
}

def defaultSystem() { prog: => Unit / System }: Unit = {
  try {
    prog();
  } with System {
    def internalStep() = {
      resume {
        ()
      }
    }
  }
}

def addC[A, T, With, Without]()
{ query: Query[T, With, Without] }
{ prog: => Unit / Query[(T, A), With, Without] }: Unit /
{ ArchManager, QueryManager, Component[A] } = {
  val compId = do getComponentId[A]();
  var matchingArchIds = resizableArray(0);
  var lastChangeVersion = 0;
  val (withIds, withoutIds) = query.internalGetWithWithoutIds();
  withIds.update(compId, ());
  def updateQuery() = {
    (do internalGetQueryArchIds(withIds, withIds, lastChangeVersion)).map() { result =>
      matchingArchIds = result.first;
      lastChangeVersion = result.second;
    };
    ()
  }
  try {
    prog();
  } with Query[(T, A), With, Without] {
    def foreachRO() = {
      resume { { action } =>
        updateQuery();
        try {
          with do internalIterEntities(matchingArchIds, false);
          with query.iterRO();
          with do internalIterRO[A](matchingArchIds);
          loop {
            action(do read(), (do read(), do read()));
          }
        } with stop {
          ()
        }
      }
    }
    def foreachRW() = {
      resume { { action } =>
        updateQuery();
        try {
          with do internalIterEntities(matchingArchIds, false);
          with query.iterRW();
          with do internalIterRW[A](matchingArchIds);
          loop {
            val value = action(do read(), (do read(), do read()));
            do emit(value.first);
            do emit(value.second);
          }
        } with stop {
          ()
        }
      }
    }
    def iterRO() = {
      resume { { prog } =>
        with query.iterRO();
        with do internalIterRO[A](matchingArchIds);
        try {
          prog();
        } with read[(T, A)] {
          resume {
            (do read(), do read())
          }
        }
      }
    }
    def iterRW() = {
      resume { { prog } =>
        with query.iterRW();
        with do internalIterRW[A](matchingArchIds);
        try {
          prog();
        } with read[(T, A)] {
          resume {
            (do read(), do read())
          }
        } with emit[(T, A)] { value =>
          do emit(value.first);
          do emit(value.second);
          resume(())
        }
      }
    }
    def internalGetWithWithoutIds() = {
      resume((withIds, withoutIds))
    }
  }
}

def addOptC[A, T, With, Without]()
  { query: Query[T, With, Without] }
  { prog: => Unit / Query[(T, Option[A]), With, Without] }: Unit /
  { ArchManager, QueryManager, Component[A] } = {
  var matchingArchIds = resizableArray(0);
  var lastChangeVersion = 0;
  val (withIds, withoutIds) = query.internalGetWithWithoutIds();
  def updateQuery() = {
    (do internalGetQueryArchIds(withIds, withIds, lastChangeVersion)).map() { result =>
      matchingArchIds = result.first;
      lastChangeVersion = result.second;
    };
    ()
  }
  try {
    prog();
  } with Query[(T, Option[A]), With, Without] {
    def foreachRO() = {
      resume { { action } =>
        if (withIds.size() > 0) {
          updateQuery();
        }
        try {
          with do internalIterEntities(matchingArchIds, withIds.size() == 0);
          with query.iterRO();
          with do internalIterOptRO[A](matchingArchIds, withIds.size() == 0);
          loop {
            action(do read(), (do read(), do read()));
          }
        } with stop {
          ()
        }
      }
    }
    def foreachRW() = {
      resume { { action } =>
        if (withIds.size() > 0) {
          updateQuery();
        }
        try {
          with do internalIterEntities(matchingArchIds, withIds.size() == 0);
          with query.iterRW();
          with do internalIterOptRW[A](matchingArchIds, withIds.size() == 0);
          loop {
            val value = action(do read(), (do read(), do read()));
            do emit(value.first);
            do emit(value.second);
          }
        } with stop {
          ()
        }
      }
    }
    def iterRO() = {
      resume { { prog } =>
        with query.iterRO();
        with do internalIterOptRO[A](matchingArchIds, withIds.size() == 0);
        try {
          prog();
        } with read[(T, Option[A])] {
          resume {
            (do read(), do read())
          }
        }
      }
    }
    def iterRW() = {
      resume { { prog } =>
        with query.iterRW();
        with do internalIterOptRW[A](matchingArchIds, withIds.size() == 0);
        try {
          prog();
        } with read[(T, Option[A])] {
          resume {
            (do read(), do read())
          }
        } with emit[(T, Option[A])] { value =>
          do emit(value.first);
          do emit(value.second);
          resume(())
        }
      }
    }
    def internalGetWithWithoutIds() = {
      resume((withIds, withoutIds))
    }
  }
}

def withC[A, T, With, Without]()
  { query: Query[T, With, Without] }
  { prog: => Unit / Query[T, (With, A), Without] }: Unit / Component[A] = {
  val compId = do getComponentId[A]();
  var matchingArchIds: ResizableArray[Int] = resizableArray(0);
  var lastChangeVersion = 0;
  val (withIds, withoutIds) = query.internalGetWithWithoutIds();
  withIds.update(compId, ());
  try {
    prog();
  } with Query[T, (With, A), Without] {
    def foreachRO() = {
      resume { { action } =>
        query.foreachRO() { action };
      }
    }
    def foreachRW() = {
      resume { { action } =>
        query.foreachRW() { action };
      }
    }
    def iterRO() = {
      resume { { prog } =>
        query.iterRO() { prog };
      }
    }
    def iterRW() = {
      resume { { prog } =>
        query.iterRW() { prog };
      }
    }
    def internalGetWithWithoutIds() = {
      resume((withIds, withoutIds))
    }
  }
}

def withoutC[A, T, With, Without]()
  { query: Query[T, With, Without] }
  { prog: => Unit / Query[T, With, (Without, A)] }: Unit / Component[A] = {
  val compId = do getComponentId[A]();
  var matchingArchIds: ResizableArray[Int] = resizableArray(0);
  var lastChangeVersion = 0;
  val (withIds, withoutIds) = query.internalGetWithWithoutIds();
  withoutIds.update(compId, ());
  try {
    prog();
  } with Query[T, With, (Without, A)] {
    def foreachRO() = {
      resume { { action } =>
        query.foreachRO() { action };
      }
    }
    def foreachRW() = {
      resume { { action } =>
        query.foreachRW() { action };
      }
    }
    def iterRO() = {
      resume { { prog } =>
        query.iterRO() { prog };
      }
    }
    def iterRW() = {
      resume { { prog } =>
        query.iterRW() { prog };
      }
    }
    def internalGetWithWithoutIds() = {
      resume((withIds, withoutIds))
    }
  }
}

def queryManager() { prog: => Unit / QueryManager }: Unit / ArchManager = {
  try {
    prog();
  } with QueryManager {
    def query[T]() = {
      resume { { prog } =>
        val compId = do getComponentId[T]();
        var matchingArchIds = resizableArray(0);
        var lastChangeVersion = 0;
        val withIds = emptyMap();
        val withoutIds = emptyMap();
        withIds.update(compId, ());
        def updateQuery() = {
          (do internalGetQueryArchIds(withIds, withIds, lastChangeVersion)).map() { result =>
            matchingArchIds = result.first;
            lastChangeVersion = result.second;
          };
          ()
        }
        try {
          prog();
        } with Query[T, Unit, Unit] {
          def foreachRO() = {
            resume { { action } =>
              updateQuery();
              try {
                with do internalIterEntities(matchingArchIds, false);
                with do internalIterRO[T](matchingArchIds);
                loop {
                  action(do read(), do read());
                }
              } with stop {
                ()
              }
            }
          }
          def foreachRW() = {
            resume { { action } =>
              updateQuery();
              try {
                with do internalIterEntities(matchingArchIds, false);
                with do internalIterRW[T](matchingArchIds);
                loop {
                  do emit(action(do read(), do read()));
                }
              } with stop {
                ()
              }
            }
          }
          def iterRO() = {
            resume { { prog } =>
              with do internalIterRO[T](matchingArchIds);
              prog();
            }
          }
          def iterRW() = {
            resume { { prog } =>
              with do internalIterRW[T](matchingArchIds);
              prog();
            }
          }
          def internalGetWithWithoutIds() = {
            resume((withIds, withoutIds))
          }
        }
      }
    }
    def optQuery[T]() = {
      resume { { prog } =>
        var matchingArchIds = resizableArray(0);
        var lastChangeVersion = 0;
        val withIds = emptyMap();
        val withoutIds = emptyMap();
        try {
          prog();
        } with Query[Option[T], Unit, Unit] {
          def foreachRO() = {
            resume { { action } =>
              try {
                with do internalIterEntities(matchingArchIds, true);
                with do internalIterOptRO[T](matchingArchIds, true);
                loop {
                  action(do read(), do read());
                }
              } with stop {
                ()
              }
            }
          }
          def foreachRW() = {
            resume { { action } =>
              try {
                with do internalIterEntities(matchingArchIds, true);
                with do internalIterOptRW[T](matchingArchIds, true);
                loop {
                  do emit(action(do read(), do read()));
                }
              } with stop {
                ()
              }
            }
          }
          def iterRO() = {
            resume { { prog } =>
              with do internalIterOptRO[T](matchingArchIds, true);
              prog();
            }
          }
          def iterRW() = {
            resume { { prog } =>
              with do internalIterOptRW[T](matchingArchIds, true);
              prog();
            }
          }
          def internalGetWithWithoutIds() = {
            resume((withIds, withoutIds))
          }
        }
      }
    }
    def allQuery() = {
      resume { { prog } =>
        var matchingArchIds = resizableArray(0);
        var lastChangeVersion = 0;
        val withIds = emptyMap();
        val withoutIds = emptyMap();
        try {
          prog();
        } with  Query[Unit, Unit, Unit] {
          def foreachRO() = {
            resume { { action } =>
              try {
                with do internalIterEntities(matchingArchIds, true);
                loop {
                  action(do read(), ());
                }
              } with stop {
                ()
              }
            }
          }
          def foreachRW() = {
            resume { { action } =>
              try {
                with do internalIterEntities(matchingArchIds, true);
                loop {
                  action(do read(), ());
                }
              } with stop {
                ()
              }
            }
          }
          def iterRO() = {
            resume { { prog } =>
              try {
                prog();
              } with read[Unit] {
                do stop();
              }
            }
          }
          def iterRW() = {
            resume { { prog } =>
              try {
                prog();
              } with read[Unit] {
                do stop();
              } with emit[Unit] { _ =>
                resume(())
              }
            }
          }
          def internalGetWithWithoutIds() = {
            resume((withIds, withoutIds))
          }
        }
      }
    }
  }
}

def world()
{ prog: => Unit /
  { Resource[RunWorld], ComponentManager, ArchManager, EntityManager, System, QueryManager, World }
}: Unit = {
  with createResource[RunWorld](RunWorld(true));
  with componentManager();
  with archManager();
  with entityIdManager();
  with entityManager();
  with defaultSystem();
  with queryManager();
  def stepWorld() = {
    do internalStep();
  }
  try {
    prog();
  } with World {
    def stepWorld() = {
      resume {
        stepWorld();
      }
    }
    def runWorld() = {
      resume {
        loop { { l } =>
          if (not((do getResource[RunWorld]()).run)) {
            l.break();
          }
          // TEMP: Slightly longer runtime before memory crash
          wait(10);
          //wait(0);
          stepWorld();
        }
      }
    }
  }
}
