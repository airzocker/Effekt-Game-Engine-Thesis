module ecs

import resizable_array
import mutable/map

import game_engine_lib/core

interface ComponentStore[T] {
  def get(archId: Int, index: Int): T
  def set(archId: Int, index: Int, value: T): Unit
  def push(archId: Int, value: T): Int
  def swapRemove(archId: Int, index: Int): Option[Int]
  def iterateArch(archId: Int): Iterator[T] at {global}
  def getArchIdToIndexMap(): Map[Int, Int]
}

def componentStore[T]{ prog: => Unit / ComponentStore[T] }: Unit = {
  val archVectors = resizableArray[ResizableArray[T]](4);
  val archIdToIndexMap = emptyMap[Int, Int]();
  val archIndexToIdMap = emptyMap[Int, Int]();
  try {
    prog();
  } with ComponentStore[T] {
    def get(archId: Int, index: Int) = {
      resume(
        archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).unsafeGet(index)
      )
    }
    def set(archId: Int, index: Int, value: T) = {
      resume(
        archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).unsafeSet(index, value)
      )
    }
    def push(archId: Int, value: T) = {
      resume(
        archIdToIndexMap.get(archId) match {        
          case Some(archIndex) => archVectors.unsafeGet(archIndex).add(value)
          case None() => {
            val newArchIndex = archVectors.size();
            val newArchVector = resizableArray(4);
            newArchVector.add(value);
            archVectors.add(newArchVector);
            archIdToIndexMap.update(archId, newArchIndex);
            archIndexToIdMap.update(newArchIndex, archId)
            0
          }
        }
      )
    }
    def swapRemove(archId: Int, index: Int) = {
      val archIndex = archIdToIndexMap.unsafeGet(archId);
      val arr = archVectors.unsafeGet(archIndex);
      val swapIndex = arr.removeSwap(index);
      if (arr.size() == 0) {
        archVectors.removeSwap(archIndex) match {
          case Some(i) => {
            val swappedArchId = archIndexToIdMap.unsafeGet(i);
            archIndexToIdMap.update(archIndex, swappedArchId);
            archIdToIndexMap.update(swappedArchId, archIndex);
          }
          case None() => ()
        }
        archIndexToIdMap.delete(archVectors.size());
        archIdToIndexMap.delete(archId);
      }
      resume(
        swapIndex
      )
    }
    def iterateArch(archId: Int) = {
      resume(
        archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).iterate()
      )
    }
    def getArchIdToIndexMap() = {
      resume(
        archIdToIndexMap
      )
    }
  }
}

interface System {
  def run(): Unit
}

def testFun() { test: => Unit } { prog: => Unit / System }: Unit = {
  try {
    prog();
  } with System {
    def run() = {
      test();
      resume(())
    }
  }
}

interface World {
  //def pushBackSystem() { body: => Unit }: Unit
  def stepWorld(): Unit
  def runWorld(): Unit
}

def defaultWorld() { prog: => Unit / World }: Unit = {
  val systems: ResizableArray[System at {global, io}] = resizableArray();
  def step() = {
    systems.foreach() { system =>
      system.run()
    };
  }
  try {
    prog();
  } with World {
    /*
    def pushBackSystem() { body: => Unit } = {
      val system = new System {
        def run() = {
          body();
        }
      }
      resume(
        systems.add(system)
      )
    }
    */
    def stepWorld() = {
      step();
      resume(())
    }
    def runWorld() = {
      loop { { l } =>
        step();
      }
    }
  }
}