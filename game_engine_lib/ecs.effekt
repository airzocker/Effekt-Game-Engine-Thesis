module ecs

import resizable_array
import mutable/map

import game_engine_lib/core

interface TypeManager {
  def getNextTypeId(): Int
}

def defaultTypeManager() { prog: => Unit / TypeManager }: Unit / {} = {
  var lastTypeId = 0;
  try {
    prog();
  } with TypeManager {
    def getNextTypeId() = {
      lastTypeId = lastTypeId + 1;
      resume(lastTypeId)
    }
  }
}

interface ComponentStore[T] {
  def getTypeId(): Int
  def get(archId: Int, index: Int): T
  def set(archId: Int, index: Int, value: T): Unit
  def push(archId: Int, value: T): Int
  def swapRemove(archId: Int, index: Int): Option[Int]
  def iterateArch(archId: Int): Iterator[T] at {global}
  def getArchIdToIndexMap(): Map[Int, Int]
}

def createcomponentStore[T]: ComponentStore[T] at {global, io} / TypeManager = {
  val typeId = do getNextTypeId();
  val archVectors = resizableArray[ResizableArray[T]](4);
  val archIdToIndexMap = emptyMap[Int, Int]();
  val archIndexToIdMap = emptyMap[Int, Int]();
  new ComponentStore[T] {
    def getTypeId() = {
      typeId
    }
    def get(archId: Int, index: Int) = {
      archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).unsafeGet(index)
    }
    def set(archId: Int, index: Int, value: T) = {
      archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).unsafeSet(index, value);
    }
    def push(archId: Int, value: T) = {
      archIdToIndexMap.get(archId) match {        
        case Some(archIndex) => archVectors.unsafeGet(archIndex).add(value)
        case None() => {
          val newArchIndex = archVectors.size();
          val newArchVector = resizableArray(4);
          newArchVector.add(value);
          archVectors.add(newArchVector);
          archIdToIndexMap.update(archId, newArchIndex);
          archIndexToIdMap.update(newArchIndex, archId)
          0
        }
      }
    }
    def swapRemove(archId: Int, index: Int) = {
      val archIndex = archIdToIndexMap.unsafeGet(archId);
      val arr = archVectors.unsafeGet(archIndex);
      val swapIndex = arr.removeSwap(index);
      if (arr.size() == 0) {
        archVectors.removeSwap(archIndex) match {
          case Some(i) => {
            val swappedArchId = archIndexToIdMap.unsafeGet(i);
            archIndexToIdMap.update(archIndex, swappedArchId);
            archIdToIndexMap.update(swappedArchId, archIndex);
          }
          case None() => ()
        }
        archIndexToIdMap.delete(archVectors.size());
        archIdToIndexMap.delete(archId);
      }
      swapIndex
    }
    def iterateArch(archId: Int) = {
      archVectors.unsafeGet(archIdToIndexMap.unsafeGet(archId)).iterate()
    }
    def getArchIdToIndexMap() = {
      archIdToIndexMap
    }
  }
}

interface ComponentManager[T] {
  def getComponentStore(): ComponentStore[T] at {global, io}
}

def componentManager[T]() { prog: => Unit / ComponentManager[T] } = {
  val componentStore = createcomponentStore();
  try {
    prog();
  } with ComponentManager[T] {
    def getComponentStore() = {
      resume(componentStore)
    }
  }
}

interface ResourceStore[T] {
  def getTypeId(): Int
  def get(): T
  def set(value: T): Unit
}

def createResourceStore[T](value: T): ResourceStore[T] at {global} / TypeManager = {
  val typeId = do getNextTypeId();
  var resourceValue in global = value;
  new ResourceStore[T] {
    def getTypeId() = {
      typeId
    }
    def get() = {
      resourceValue
    }
    def set(value: T) = {
      resourceValue = value;
    }
  }
}

interface ResourceManager[T] {
  def getResourceStore(): ResourceStore[T] at {global}
}

def resourceManager[T](value: T) { prog: => Unit / ResourceManager[T] } = {
  val resourceStore = createResourceStore(value);
  try {
    prog();
  } with ResourceManager[T] {
    def getResourceStore() = {
      resume(resourceStore)
    }
  }
}

def getArchIterators[
  A
](
  componentStoreA: ComponentStore[A] at {global, io}
) = {
  val chainsA = resizableArray();
  componentStoreA.getArchIdToIndexMap().keys().foreach() { archId =>
    chainsA.add(componentStoreA.iterateArch(archId));
    ()
  };
  (
    chainsA.iterateChain()
  )
}

def getArchIterators[
  A,
  B
](
  componentStoreA: ComponentStore[A] at {global, io},
  componentStoreB: ComponentStore[B] at {global, io}
) = {
  val chainsA = resizableArray();
  val chainsB = resizableArray();
  val archIdToIndexMapB = componentStoreB.getArchIdToIndexMap[B]();
  componentStoreA.getArchIdToIndexMap().keys().foreach() { archId =>
    if (
      archIdToIndexMapB.get(archId).isDefined()
    ) {
      chainsA.add(componentStoreA.iterateArch(archId));
      chainsB.add(componentStoreB.iterateArch(archId));
      ()
    }
  };
  (
    chainsA.iterateChain(),
    chainsB.iterateChain()
  )
}

interface System {
  def run(): Unit
}

def createSystem() { body: => Unit } = {
  new System {
    def run() = {
      body();
    }
  }
}

def createSystem[
  A
](body: (
  Iterator[A] at {global}
) => Unit at {global, io}): System at {global, io} / {
  ComponentManager[A]
} = {
  val componentStoreA = do getComponentStore[A]();
  new System {
    def run() = {
      getArchIterators(
        componentStoreA
      ) match {
        case iterA => body(
          iterA
        );
      }
    }
  }
}

def createSystem[
  A,
  B
](body: (
  Iterator[A] at {global},
  Iterator[B] at {global}
) => Unit at {global, io}): System at {global, io} / {
  ComponentManager[A],
  ComponentManager[B]
} = {
  val componentStoreA = do getComponentStore[A]();
  val componentStoreB = do getComponentStore[B]();
  new System {
    def run() = {
      getArchIterators(
        componentStoreA,
        componentStoreB
      ) match {
        case (
          iterA,
          iterB
        ) => body(
          iterA,
          iterB
        );
      }
    }
  }
}

interface World {
  def pushBackSystem(system: System at {global, io}): Unit
  def stepWorld(): Unit
  def runWorld(): Unit
}

def defaultWorld() { prog: => Unit / World }: Unit / {} = {
  val systems: ResizableArray[System at {global, io}] = resizableArray();
  def step() = {
    systems.foreach() { system =>
      system.run();
    };
  }
  try {
    prog();
  } with World {
    def pushBackSystem(system) = {
      systems.add(system);
      resume(())
    }
    def stepWorld() = {
      step();
      resume(())
    }
    def runWorld() = {
      loop { { l } =>
        step();
      }
    }
  }
}