module ecs

import resizable_array
import mutable/map
import io
import io/time
import stream

import game_engine_lib/core
import game_engine_lib/engine

record Entity(id: Int)

record EntityData(archId: Int, componentIndex: Int)

type RemoveSwapResult {
  Swapped(index: Int);
  NoSwap();
  Empty();
}

interface ComponentManager {
  def nextComponentId(): Int
}

def componentManager() { prog: => Unit / ComponentManager } = {
  var lastComponentId = 0;
  try {
    prog();
  } with ComponentManager {
    def nextComponentId() = {
      lastComponentId = lastComponentId + 1;
      resume(lastComponentId)
    }
  }
}

interface Component[T] {
  def getId(): Int
  def iterRO(archId: Int) { prog: => Unit / read[T] }: Unit / stop
  def iterRW(archId: Int) { prog: => Unit / { read[T], emit[T] } }: Unit / stop
  def addComponent(archId: Int, value: T): Int
  def removeSwapComponent(archId: Int, index: Int): RemoveSwapResult
  def getComponent(archId: Int, index: Int): T
  def setComponent(archId: Int, index: Int, value: T): Unit
}

def component[T]() { prog: => Unit / Component[T] }: Unit / ComponentManager = {
  val componentId = do nextComponentId();
  val componentStore: Map[Int, ResizableArray[T]] = emptyMap();
  try {
    prog();
  } with Component[T] {
    def getId() = {
      resume(componentId)
    }
    def iterRO(archId) = {
      resume { { prog } =>
        val components = componentStore.unsafeGet(archId);
        var index = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (index < components.size()) {
              val component = components.unsafeGet(index);
              index = index + 1;
              component
            } else {
              do stop()
            }
          }
        }
      }
    }
    def iterRW(archId) = {
      resume { { prog } =>
        val components = componentStore.unsafeGet(archId);
        var readIndex = 0;
        var writeIndex = 0;
        try {
          prog();
        } with read[T] {
          resume {
            if (readIndex < components.size()) {
              val component = components.unsafeGet(readIndex);
              readIndex = readIndex + 1;
              component
            } else {
              do stop()
            }
          }
        } with emit[T] { value =>
          if (writeIndex < components.size()) {
            components.unsafeSet(writeIndex, value);
            writeIndex = writeIndex + 1;
          }
          resume(())
        }
      }
    }
    def addComponent(archId, value) = {
      val components = componentStore.get(archId) match {
        case Some(components) => components
        case None() =>
          val components = resizableArray(4);
          componentStore.update(archId, components);
          components
      }
      val index = components.size();
      components.add(value);
      resume(index)
    }
    def removeSwapComponent(archId, index) = {
      val components = componentStore.unsafeGet(archId);
      val swapped = components.removeSwap(index);
      if (components.size() == 0) {
        componentStore.delete(archId);
        resume(Empty())
      }
      swapped match {
        case Some(swapped) => resume(Swapped(swapped))
        case None() => resume(NoSwap())
      }
    }
    def getComponent(archId, index) = {
      resume(
        componentStore.get(archId) match {
          case Some(components) => components.unsafeGet(index)
          case None() => panic("Archetype with id " ++ archId.show() ++ " does not contain components of type id " ++ componentId.show() ++ "!");
        }
      )
    }
    def setComponent(archId, index, value) = {
      resume(
        componentStore.get(archId) match {
          case Some(components) => components.unsafeSet(index, value);
          case None() => panic("Archetype with id " ++ archId.show() ++ " does not contain components of type id " ++ componentId.show() ++ "!");
        }
      )
    }
  }
}

interface Components[T] {
  def getIds(): ResizableArray[Int]
  def iterTuplesRO(archId: Int) { prog: => Unit / read[T] }: Unit / stop
  def iterTuplesRW(archId: Int) { prog: => Unit / { read[T], emit[T] } }: Unit / stop
  def addComponentTuple(archId: Int, value: T): Int
  def removeSwapComponentTuple(archId: Int, index: Int): RemoveSwapResult
}

def zipComponents() { prog: => Unit / Components[Unit] } = {
  val componentIds = resizableArray(0);
  try {
    prog();
  } with Components[Unit] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        try {
          prog();
        } with read[Unit] {
          resume {
            ()
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        try {
          prog();
        } with read[Unit] {
          resume {
            ()
          }
        } with emit[Unit] { value =>
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      println("addTuple for Unit Components makes no sense!");
      resume(0)
    }
    def removeSwapComponentTuple(archId, index) = {
      println("removeSwapTuple for Unit Components makes no sense!");
      resume(NoSwap())
    }
  }
}

def zipComponents[
  A
]() { prog: => Unit / Components[(
  A
)] }: Unit / {
  Component[A]
} = {
  val componentIds = resizableArray(1);
  componentIds.add(do getId[A]());
  try {
    prog();
  } with Components[(
    A
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        try {
          prog();
        } with read[(
          A
        )] {
          resume {
            (
              do read[A]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        try {
          prog();
        } with read[(
          A
        )] {
          resume {
            (
              do read[A]()
            )
          }
        } with emit[(
          A
        )] { value =>
          value match {
            case a =>
              do emit(a);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case a =>
            do addComponent(archId, a)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      resume(
        do removeSwapComponent[A](archId, index)
      )
    }
  }
}

def zipComponents[
  A,
  B
]() { prog: => Unit / Components[(
  A,
  B
)] }: Unit / {
  Component[A],
  Component[B]
} = {
  val componentIds = resizableArray(2);
  componentIds.add(do getId[A]());
  componentIds.add(do getId[B]());
  componentIds.bubbleSortInt();
  try {
    prog();
  } with Components[(
    A,
    B
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        try {
          prog();
        } with read[(
          A,
          B
        )] {
          resume {
            (
              do read[A](),
              do read[B]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        try {
          prog();
        } with read[(
          A,
          B
        )] {
          resume {
            (
              do read[A](),
              do read[B]()
            )
          }
        } with emit[(
          A,
          B
        )] { value =>
          value match {
            case (
              a,
              b
            ) =>
              do emit(a);
              do emit(b);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      resume(
        do removeSwapComponent[B](archId, index)
      )
    }
  }
}

def zipComponents[
  A,
  B,
  C
]() { prog: => Unit / Components[(
  A,
  B,
  C
)] }: Unit / {
  Component[A],
  Component[B],
  Component[C]
} = {
  val componentIds = resizableArray(3);
  componentIds.add(do getId[A]());
  componentIds.add(do getId[B]());
  componentIds.add(do getId[C]());
  componentIds.bubbleSortInt();
  try {
    prog();
  } with Components[(
    A,
    B,
    C
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C]()
            )
          }
        } with emit[(
          A,
          B,
          C
        )] { value =>
          value match {
            case (
              a,
              b,
              c
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b,
            c
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b);
            do addComponent(archId, c)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      do removeSwapComponent[B](archId, index);
      resume(
        do removeSwapComponent[C](archId, index)
      )
    }
  }
}

def zipComponents[
  A,
  B,
  C,
  D
]() { prog: => Unit / Components[(
  A,
  B,
  C,
  D
)] }: Unit / {
  Component[A],
  Component[B],
  Component[C],
  Component[D]
} = {
  val componentIds = resizableArray(4);
  componentIds.add(do getId[A]());
  componentIds.add(do getId[B]());
  componentIds.add(do getId[C]());
  componentIds.add(do getId[D]());
  componentIds.bubbleSortInt();
  try {
    prog();
  } with Components[(
    A,
    B,
    C,
    D
  )] {
    def getIds() = {
      resume(componentIds)
    }
    def iterTuplesRO(archId) = {
      resume { { prog } =>
        with do iterRO[A](archId);
        with do iterRO[B](archId);
        with do iterRO[C](archId);
        with do iterRO[D](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D]()
            )
          }
        }
      }
    }
    def iterTuplesRW(archId) = {
      resume { { prog } =>
        with do iterRW[A](archId);
        with do iterRW[B](archId);
        with do iterRW[C](archId);
        with do iterRW[D](archId);
        try {
          prog();
        } with read[(
          A,
          B,
          C,
          D
        )] {
          resume {
            (
              do read[A](),
              do read[B](),
              do read[C](),
              do read[D]()
            )
          }
        } with emit[(
          A,
          B,
          C,
          D
        )] { value =>
          value match {
            case (
              a,
              b,
              c,
              d
            ) =>
              do emit(a);
              do emit(b);
              do emit(c);
              do emit(d);
          }
          resume(())
        }
      }
    }
    def addComponentTuple(archId, value) = {
      resume(
        value match {
          case (
            a,
            b,
            c,
            d
          ) =>
            do addComponent(archId, a);
            do addComponent(archId, b);
            do addComponent(archId, c);
            do addComponent(archId, d)
        }
      )
    }
    def removeSwapComponentTuple(archId, index) = {
      do removeSwapComponent[A](archId, index);
      do removeSwapComponent[B](archId, index);
      do removeSwapComponent[C](archId, index);
      resume(
        do removeSwapComponent[D](archId, index)
      )
    }
  }
}

interface ArchManager {
  def addArch(componentIds: ResizableArray[Int]): Int
  def removeArch(archId: Int): Unit
  def addUpdateQuery(componentIds: ResizableArray[Int], archIds: Ref[ResizableArray[Int]]): Unit
  def updateQueries(): Unit
}

def archManager() { prog: => Unit / ArchManager } = {
  val archs = resizableArray(4);
  val freeIndices = resizableArray(4);
  var hasChanged = false;
  var updateQueries = resizableArray(4);
  def addArch(componentIds: ResizableArray[Int]) = {
    hasChanged = true;
    try {
      archs.unsafeSet(freeIndices.popRight(), componentIds);
    } with Exception[OutOfBounds] {
      def raise(_: OutOfBounds, _: String) = {
        ()
      }
    }
    archs.add(componentIds);
  }
  def updateFindArchs(componentIds: ResizableArray[Int], archIds: Ref[ResizableArray[Int]]) = {
    val newArchIds = resizableArray(4);
    archs.foreachIndex() { (archId, arch) { l } =>
      var findIndex = 0;
      arch.foreach() { (compnentId) { sl } =>
        if (findIndex >= componentIds.size()) {
          sl.break();
        }
        val searchId = componentIds.unsafeGet(findIndex);
        if (compnentId > searchId) {
          l.continue();
        }
        if (compnentId == searchId) {
          findIndex = findIndex + 1;
        }
      }
      if (findIndex == componentIds.size()) {
        newArchIds.add(archId);
        ()
      }
    }
    archIds.set(newArchIds);
  }
  try {
    prog();
  } with ArchManager {
    def addArch(componentIds) = {
      var archId = -1;
      archs.foreachIndex() { (id, arch) { l } =>
        if (arch.size() != componentIds.size()) {
          l.continue();
        }
        each(0, arch.size()) { index =>
          if (arch.unsafeGet(index) != componentIds.unsafeGet(index)) {
            l.continue();
          }
        }
        archId = id;
        l.break();
      }
      if (archId < 0) {
        archId = addArch(componentIds);
      }
      resume(archId)
    }
    def removeArch(archId) = {
      if (archId < archs.size()) {
        hasChanged = true;
        archs.unsafeSet(archId, resizableArray(0));
        freeIndices.add(archId);
        ()
      }
      resume(())
    }
    def addUpdateQuery(componentIds, archIds) = {
      updateQueries.add((componentIds, archIds));
      resume(())
    }
    def updateQueries() = {
      if (hasChanged) {
        updateQueries.foreach() { value =>
          value match {
            case (componentIds, archIds) => {
              updateFindArchs(componentIds, archIds);
            }
          }
        }
        hasChanged = false;
      }
      resume(())
    }
  }
}

interface EntityManager {
  def addEntity[T](components: T): Entity / Components[T]
  def destroyEntity[T](entity: Entity): Unit / Components[T]
  def getComponent[T](entity: Entity): T / Component[T]
  def setComponent[T](entity: Entity, value: T): Unit / Component[T]
}

def entityManager() { prog: => Unit / EntityManager }: Unit / ArchManager = {
  val entityDatas: Map[Entity, EntityData] = emptyMap();
  val entityDataToEntity: Map[EntityData, Entity] = emptyMap();
  var lastEntityId = 0;
  def nextEntityId() = {
    lastEntityId = lastEntityId + 1;
    lastEntityId
  }
  try {
    prog();
  } with EntityManager {
    def addEntity[T](components) = {
      resume {
        val entity = Entity(nextEntityId());      
        val archId = do addArch(do getIds[T]());
        val componentIndex = do addComponentTuple(archId, components);
        val entityData = EntityData(archId, componentIndex);
        entityDatas.update(entity, entityData);
        entityDataToEntity.update(entityData, entity);
        entity 
      }
    }
    def destroyEntity[T](entity) = {
      resume {
        entityDatas.get(entity) match {
          case Some(entityData) =>
            entityDatas.delete(entity);
            do removeSwapComponentTuple[T](entityData.archId, entityData.componentIndex) match {
              case Swapped(swapped) =>
                val swappedData = EntityData(entityData.archId, swapped);
                val swappedEntity = entityDataToEntity.unsafeGet(swappedData);
                entityDatas.update(swappedEntity, entityData);
                entityDataToEntity.update(entityData, swappedEntity);
                entityDataToEntity.delete(swappedData);
              case NoSwap() =>
                entityDataToEntity.delete(entityData);
              case Empty() =>
                entityDataToEntity.delete(entityData);
                do removeArch(entityData.archId);
            }
          case None() => println("Trying to remove nonexistent Entity with id " ++ entity.id.show() ++ "!");
        }
        ()
      }
    }
    def getComponent[T](entity) = {
      resume {
        val (archId, componentIndex) = entityDatas.get(entity) match {
          case Some(EntityData(archId, componentIndex)) => (archId, componentIndex)
          case None() => panic("Trying to get component of nonexistent Entity with id " ++ entity.id.show() ++ "!")
        };
        do getComponent[T](archId, componentIndex)
      }
    }
    def setComponent[T](entity, value) = {
      resume {
        val (archId, componentIndex) = entityDatas.get(entity) match {
          case Some(EntityData(archId, componentIndex)) => (archId, componentIndex)
          case None() => panic("Trying to get component of nonexistent Entity with id " ++ entity.id.show() ++ "!")
        };
        do setComponent[T](archId, componentIndex, value);
      }
    }
  }
}

interface Query[T] {
  def foreachRO() { action: T => Unit }: Unit
  def foreachRW() { action: T => T }: Unit
}

def query[T]() { prog: => Unit / Query[T] }: Unit / { ArchManager, Components[T] } = {
  val archIds = ref(resizableArray(0));
  do addUpdateQuery(do getIds[T](), archIds);
  try {
    prog();
  } with Query[T] {
    def foreachRO() = {
      resume { { action } =>
        archIds.get().foreach() { archId =>
          try {
            with do iterTuplesRO[T](archId);
            loop {
              action(do read());
            }
          } with stop {
            ()
          }
        }
      }
    }
    def foreachRW() = {
      resume { { action } =>
        archIds.get().foreach() { archId =>
          try {
            with do iterTuplesRW[T](archId);
            loop {
              do emit(action(do read()));
            }
          } with stop {
            ()
          }
        }
      }
    }
  }
}

interface System {
  def step(): Unit
}

def defaultSystem() { prog: => Unit / System } = {
  try {
    prog();
  } with System {
    def step() = {
      resume(())
    }
  }
}

def addSystemRO[T]() { action: T => Unit } { prog: => Unit / System }: Unit / { ArchManager, System, Components[T] } = {
  with query[T]();
  try {
    prog();
  } with System {
    def step() = {
      do step();
      do foreachRO[T]() { action }
      resume(())
    }
  }
}

def addSystemRW[T]() { action: T => T } { prog: => Unit / System }: Unit / { ArchManager, System, Components[T] } = {
  with query[T]();
  try {
    prog();
  } with System {
    def step() = {
      do step();
      do foreachRW[T]() { action }
      resume(())
    }
  }
}

interface World {
  def stepWorld(): Unit / System
  def runWorld(): Unit / System
}

def world() { prog: => Unit / { World, System, ComponentManager, ArchManager, EntityManager } } = {
  with defaultSystem();
  with componentManager();
  with archManager();
  with entityManager();
  def stepWorld() = {
    do updateQueries();
    do step();
  }
  try {
    prog();
  } with World {
    def stepWorld() = {
      resume {
        stepWorld();
      }
    }
    def runWorld() = {
      resume {
        loop { { l } =>
          if (isInputEscape()) {
            l.break();
          }
          await(promise(box { wait(0) } ));
          stepWorld();
        }
      }
    }
  }
}