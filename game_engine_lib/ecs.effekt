module ecs

import array
import resizable_array
import mutable/map
import io
import io/time
import stream

import game_engine_lib/core

record Entity(id: Int)

record EntityData(archId: Int, entityIndex: Int)

record ComponentStore[T](values: ResizableArray[Option[T]], freeIndices: ResizableArray[Int])

record Arch(componentIndices: Map[Int, ResizableArray[Int]], entities: ResizableArray[Entity])

// Resource to signal world loop exit
record RunWorld(run: Bool)

interface ECSException {
  def invalidEntity(entity: Entity): Nothing
  def invalidComponent(entity: Entity, componentId: Int): Nothing
}

interface ComponentManager {
  def registerComponentStore[T](componentStore: Ref[ComponentStore[T]]): Int
  def removeComponent(componentId: Int, componentIndex: Int): Unit
  def copyComponent(componentId: Int, fromComponentIndex: Int, toComponentIndex: Int): Unit
}

interface Component[T] {
  def getComponentId(): Int
  def addComponent(value: T): Int
  def getComponent(index: Int): T
  def setComponent(index: Int, value: T): Unit
}

interface Resource[T] {
  def getResource(): T
  def setResource(value: T): Unit
}

interface ArchManager {
  def hasComponent(archId: Int, componentId: Int): Bool
  def addEntity(entity: Entity): EntityData
  def removeSwapEntity(entityData: EntityData): Option[Entity]
  def getComponent[T](entityData: EntityData): Option[T] / Component[T]
  def setComponent[T](entityData: EntityData, value: T): Option[Unit] / Component[T]
  def addComponent[T](entityData: EntityData, value: T): (EntityData, Option[Entity]) / Component[T]
  def addExistingComponent(entityData: EntityData, componentId: Int, componentIndex: Int): (EntityData, Option[Entity])
  def removeComponent(entityData: EntityData, componentId: Int): (EntityData, Option[Entity])
  def iterEntities(archId: Int) { prog: => Unit / read[Entity] }: Unit / stop
  def iterComponentIndices(archId: Int, componentId: Int) { prog: => Unit / read[Int] }: Unit / stop
  def getQueryArchIds(withIds: Map[Int, Unit], withoutIds: Map[Int, Unit], lastChangeVersion: Int): Option[(ResizableArray[Int], Int)]
}

interface EntityIdManager {
  def nextEntityId(): Int
}

interface EntityManager {
  def hasEntity(entity: Entity): Bool
  def hasComponent[T](entity: Entity): Bool / { Component[T], ECSException }
  def getEntityData(entity: Entity): EntityData / ECSException
  def createEntity(): Entity
  def destroyEntity(entity: Entity): Unit / ECSException
  def addComponent[T](entity: Entity, value: T): Unit / { Component[T], ECSException }
  def removeComponent[T](entity: Entity): Unit / { Component[T], ECSException }
  def getComponent[T](entity: Entity): T / { Component[T], ECSException }
  def setComponent[T](entity: Entity, value: T): Unit / { Component[T], ECSException }
}

interface Query[T, With, Without] {
  def addC[C](): Query[(T, C), With, Without] at { global, io } / Component[C]
  def withC[C](): Query[T, (With, C), Without] at { global, io } / Component[C]
  def withoutC[C](): Query[T, With, (Without, C)] at { global, io } / Component[C]
  def foreachRO() { action: (Entity, T) => Unit }: Unit
  def foreachRW() { action: (Entity, T) => T }: Unit
  def iterRO() { prog: => Unit / read[T] }: Unit / stop
  def iterRW() { prog: => Unit / { read[T], emit[T] } }: Unit / stop
  def getWithWithoutIds(): (Map[Int, Unit], Map[Int, Unit])
}

interface QueryManager {
  def query[T](): Query[T, Unit, Unit] at { global, io } 
}

interface System {
  def step(): Unit / EntityManager
}

interface World {
  def stepWorld(): Unit / System
  def runWorld(): Unit / System
  def addSystem() { body: => Unit / EntityManager }: Unit
}

def emptyComponentStore[T](): ComponentStore[T] = {
  ComponentStore(resizableArray(4), resizableArray(4))
}

def componentManager() { prog: => Unit / ComponentManager }: Unit = {
  var removeFuns: ResizableArray[Int => Unit at { global, io }] = resizableArray(4);
  var copyFuns: ResizableArray[(Int, Int) => Unit at { global, io }] = resizableArray(4);
  try {
    prog();
  } with ComponentManager {
    def registerComponentStore[T](componentStore) = {
      removeFuns.add(box { (componentIndex: Int) =>
        componentStore.get().values.unsafeSet(componentIndex, None());
        componentStore.get().freeIndices.add(componentIndex);
        ()
      });
      copyFuns.add(box { (fromComponentIndex: Int, toComponentIndex: Int) =>
        val values = componentStore.get().values;
        values.unsafeSet(toComponentIndex, values.unsafeGet(fromComponentIndex));
        ()
      });
      resume(removeFuns.size() - 1)
    }
    def removeComponent(componentId, componentIndex) = {
      (removeFuns.unsafeGet(componentId))(componentIndex);
      resume(())
    }
    def copyComponent(componentId, fromComponentIndex, toComponentIndex) = {
      (copyFuns.unsafeGet(componentId))(fromComponentIndex, toComponentIndex);
      resume(())
    }
  }
}

def component[T]() { prog: => Unit / Component[T] }: Unit / ComponentManager = {
  val componentStore = ref(emptyComponentStore());
  val componentId = do registerComponentStore(componentStore);
  try {
    prog();
  } with Component[T] {
    def getComponentId() = {
      resume((componentId))
    }
    def addComponent(value) = {
      resume(componentStore.get().add(Some(value)))
    }
    def getComponent(index) = {
      val value = componentStore.get().values.unsafeGet(index).getOrElse() {
        panic("Component[T] getComponent called on empty (None) index!");
      };
      resume(value)
    }
    def setComponent(index, value) = {
      componentStore.get().values.unsafeSet(index, Some(value));
      resume(())
    }
  }
}

def createResource[T](value: T) { prog: => Unit / Resource[T] }: Unit = {
  var resourceValue = value;
  try {
    prog();
  } with Resource[T] {
    def getResource() = {
      resume(resourceValue)
    }
    def setResource(value) = {
      resourceValue = value;
      resume(())
    }
  }
}

def archManager() { prog: => Unit / ArchManager }: Unit / ComponentManager = {
  val archs = optionArray(4);
  archs.add(Arch(emptyMap(), resizableArray(4)));
  var changeVersion = 1;
  def addArch(arch: Arch): Int = {
    changeVersion = changeVersion + 1;
    archs.add(arch)
  }
  def removeArch(archId: Int) = {
    changeVersion = changeVersion + 1;
    archs.remove(archId);
  }
  def getMatchingArchId(componentIds: Array[Int]): Option[Int] = {
    var matching = None();
    archs.arr.foreachIndex() { (i, archOpt) { l } =>
      archOpt.map() { arch =>
        if (arch.componentIndices.containsOnlyAll(componentIds)) {
          matching = Some(i);
          l.break();
        }
        ()
      }
    };
    matching
  }
  def removeSwapEntityIndices(arch: Arch, entityIndex: Int): Option[Entity] = {
    val swapped = arch.entities.removeSwap(entityIndex).map() { index =>
      arch.entities.unsafeGet(index)
    };
    arch.componentIndices.values().foreach() { indices =>
      indices.removeSwap(entityIndex);
    };
    swapped
  }
  def addExistingComponent(entityData: EntityData, componentId: Int, componentIndex: Int): (EntityData, Option[Entity]) = {
    val oldArch = archs.unsafeGet(entityData.archId);
    val newCompIndices = emptyMap();
    var sameArch = false;
    oldArch.componentIndices.keys().foreach() { (compId) { l } =>
      if (compId == componentId) {
        sameArch = true;
        l.break();
      }
      newCompIndices.update(compId, resizableArray(0));
    };
    newCompIndices.update(componentId, resizableArray(0));
    if (sameArch) {
      val oldComponentIndex = oldArch.componentIndices.unsafeGet(componentId).unsafeGet(entityData.entityIndex);
      do copyComponent(componentId, componentIndex, oldComponentIndex);
      do removeComponent(componentId, componentIndex);
      (
        entityData,
        None()
      )
    } else {
      val newArchId = getMatchingArchId(newCompIndices.keys()).getOrElse() {
        addArch(Arch(newCompIndices, resizableArray(4)))
      };
      val newArch = archs.unsafeGet(newArchId);
      val newEntityIndex = newArch.entities.add(oldArch.entities.unsafeGet(entityData.entityIndex));
      oldArch.componentIndices.keys().foreach() { compId =>
        newArch.componentIndices.unsafeGet(compId).add(oldArch.componentIndices.unsafeGet(compId).unsafeGet(entityData.entityIndex));
      };
      newArch.componentIndices.unsafeGet(componentId).add(componentIndex);
      val swapped = oldArch.removeSwapEntityIndices(entityData.entityIndex);
      if (entityData.archId > 0 && oldArch.entities.size() == 0) {
        removeArch(entityData.archId);
      }
      (
        EntityData(newArchId, newEntityIndex),
        swapped
      )
    }
  }
  try {
    prog();
  } with ArchManager {
    def hasComponent(archId, componentId) = {
      archs.unsafeGet(archId).componentIndices.get(componentId).isDefined()
    }
    def addEntity(entity) = {
      resume(EntityData(0, archs.unsafeGet(0).entities.add(entity)))
    }
    def removeSwapEntity(entityData) = {
      val arch = archs.unsafeGet(entityData.archId);
      arch.componentIds.foreach() { compId =>
        val compIndex = arch.componentIndices.unsafeGet(compId).unsafeGet(entityData.entityIndex);
        do removeComponent(compId, compIndex);
      };
      val swapped = arch.removeSwapEntityIndices(entityData.entityIndex);
      if (entityData.archId > 0 && arch.entities.size() == 0) {
        removeArch(entityData.archId);
      }
      swapped
    }
    def getComponent[T](entityData) = {
      resume {
        val compId = do getComponentId();
        archs.unsafeGet(entityData.archId).componentIndices.get(compId).map() { compIndices =>
          val compIndex = compIndices.unsafeGet(entityData.entityIndex);
          do getComponent(compIndex)
        }
      }
    }
    def setComponent[T](entityData, value) = {
      resume {
        val compId = do getComponentId();
        archs.unsafeGet(entityData.archId).componentIndices.get(compId).map() { compIndices =>
          val compIndex = compIndices.unsafeGet(entityData.entityIndex);
          do setComponent(compIndex, value);
        }
      }
    }
    def addComponent[T](entityData, value) = {
      resume {
        addExistingComponent(entityData, compId, do addComponent(value));
      }
    }
    def addExistingComponent(entityData, componentId, componentIndex) = {
      resume(addExistingComponent(entityData, componentId, componentIndex))
    }
    def removeComponent(entityData, componentId) = {
      val oldArch = archs.unsafeGet(entityData.archId);
      val newCompIndices = emptyMap();
      var sameArch = true;
      oldArch.componentIndices.keys().foreach() { compId =>
        if (compId == componentId) {
          sameArch = false;
        } else {
          newCompIndices.update(compId, resizableArray(0));
        }
      };
      if (sameArch) {
        (
          entityData,
          None()
        )
      } else {
        val newCompIds = newCompIndices.keys();
        val newArchId = getMatchingArchId(newCompIds).getOrElse() {
          addArch(Arch(newCompIndices, resizableArray(4)))
        };
        val newArch = archs.unsafeGet(newArchId);
        val newEntityIndex = newArch.entities.add(oldArch.entities.unsafeGet(entityData.entityIndex));
        newCompIds.foreach() { compId =>
          newArch.componentIndices.unsafeGet(compId).add(oldArch.componentIndices.unsafeGet(compId).unsafeGet(entityData.entityIndex));
        };
        do removeComponent(componentId, oldArch.componentIndices.unsafeGet(componentId).unsafeGet(entityData.entityIndex));
        val swapped = oldArch.removeSwapEntityIndices(entityData.entityIndex);
        if (entityData.archId > 0 && oldArch.entities.size() == 0) {
          removeArch(entityData.archId);
        }
        (
          EntityData(newArchId, newEntityIndex),
          swapped
        )
      }
    }
    def iterEntities(archId) = {
      resume { { prog } =>
        val entities = archs.unsafeGet(archId).entities;
        var index = 0;
        try {
          prog();
        } with read[Entity] {
          resume {
            if (index < entities.size()) {
              index = index + 1;
              entities.unsafeGet(index - 1)
            } else {
              do stop()
            }
          }
        }
      }
    }
    def iterComponentIndices(archId, componentId) = {
      resume { { prog } =>
        val componentIndices = archs.unsafeGet(archId).componentIndices.unsafeGet(componentId);
        var index = 0;
        try {
          prog();
        } with read[Int] {
          resume {
            if (index < componentIndices.size()) {
              index = index + 1;
              componentIndices.unsafeGet(index - 1)
            } else {
              do stop()
            }
          }
        }
      }
    }
    def getQueryArchIds(withIds, withoutIds, lastChangeVersion) = {
      if (lastChangeVersion < changeVersion) {
        val matching = resizableArray(4);
        archs.arr.foreachIndex() { (i, archOpt)
          archOpt.map() { arch =>
            val archCompIds = arch.componentIndices;
            if (archCompIds.containsAll(withIds.keys()) && archCompIds.containsNone(withoutIds.keys())) {
              matching.add();
            }
            ()
          };
        };
        Some((matching, changeVersion))
      } else {
        None()
      }
    }
  }
}

def entityIdManager() { prog: => Unit / EntityIdManager }: Unit = {
  var lastEntityId = 0;
  try {
    prog();
  } with EntityIdManager {
    def nextEntityId() = {
      lastEntityId = lastEntityId + 1;
      lastEntityId
    }
  }
}

def entityManager() { prog: Map[Int, EntityData] => Unit / EntityManager }: Unit / { ArchManager, EntityIdManager } = {
  var entityDatas: Map[Int, EntityData] = emptyMap();
  def getEntityData(entity: Entity): Entitiy / ECSException = {
    entityDatas.get(entity).getOrElse() {
      do invalidEntity(entity);
    }
  }
  try {
    prog(entityDatas);
  } with EntityManager {
    def hasEntity(entity) = {
      resume(entityDatas.get(entity).isDefined())
    }
    def hasComponent[T](entity) = {
      resume {
        val entityData = getEntityData(entity);
        do hasComponent(entityData.archId, do getComponentId())
      }
    }
    def getEntityData(entity) = {
      resume {
        getEntityData(entity)
      }
    }
    def createEntity() = {
      val entity = Entitiy(do nextEntityId());
      entityDatas.update(entity, do addEntity(entity));
      resume(entity)
    }
    def destroyEntity(entity) = {
      resume {
        val entityData = getEntityData(entity);
        do removeSwapEntity(entityData).map() { swappedEntity =>
          entityDatas.update(swappedEntity, entityData);
        };
        entityDatas.delete(entity);
      }
    }
    def addComponent[T](entity, value) = {
      resume {
        val compId = do getComponentId();
        val compIndex = do addComponent(value);
        val entityData = getEntityData(entity);
        val (newEntityData, swapped) = do addExistingComponent(entityData, compId, compIndex);
        entityDatas.update(entity, newEntityData);
        swapped.map() { swappedEntity =>
          entityDatas.update(swappedEntity, entityData);
        };
      }
    }
    def removeComponent[T](entity) = {
      resume {
        val compId = do getComponentId();
        val entityData = getEntityData(entity);
        val (newEntityData, swapped) = do removeComponent(entityData, compId);
        entityDatas.update(entity, newEntityData);
        swapped.map() { swappedEntity =>
          entityDatas.update(swappedEntity, entityData);
        };
      }
    }
    def getComponent[T](entity) = {
      resume {
        val entityData = getEntityData(entity);
        (do getComponent(entityData)).getOrElse() {
          do invalidComponent(entity, do getComponentId());
        }
      }
    }
    def setComponent[T](entity, value) = {
      resume {
        val entityData = getEntityData(entity);
        (do setComponent(entityData, value)).getOrElse() {
          do invalidComponent(entity, do getComponentId());
        }
      }
    }
  }
}

def systemEntityManager(entityDatas: Map[Int, EntityData]) { prog: => Unit / EntityManager }: Unit / { EntityIdManager, EntityManager } = {
  try {
    prog();
  } with EntityManager {
    def hasEntity(entity) = {
      resume(do hasEntity(entity))
    }
    def hasComponent[T](entity) = {
      resume{
        do hasComponent[T](entity)
      }
    }
    def getEntityData(entity) = {
      resume(do getEntityData(entity))
    }
    def createEntity() = {
      val entity = Entitiy(do nextEntityId());
      resume(entity)
      entityDatas.update(entity, do addEntity(entity));
    }
    def destroyEntity(entity) = {
      resume(())
      do destroyEntity(entity);
    }
    def addComponent[T](entity, value) = {
      var compId = 0;
      var compIndex = 0;
      resume {
        compId = do getComponentId();
        compIndex = do addComponent(value);
      }
      try {
        val entityData = do getEntityData(entity);
        val (newEntityData, swapped) = do addExistingComponent(entityData, compId, compIndex);
        entityDatas.update(entity, newEntityData);
        swapped.map() { swappedEntity =>
          entityDatas.update(swappedEntity, entityData);
        };
      } with ECSException {
        def invalidEntity(entity) = {
          do removeComponent(compId, compIndex);
          do invalidEntity(entity);
        }
        def invalidComponent(entity, componentId) = {
          do removeComponent(compId, compIndex);
          do invalidComponent(entity, componentId);
        }
      }
    }
    def removeComponent[T](entity) = {
      var compId = 0;
      resume {
        compId = do getComponentId();
      }
      val entityData = do getEntityData(entity);
      val (newEntityData, swapped) = do removeComponent(entityData, compId);
      entityDatas.update(entity, newEntityData);
      swapped.map() { swappedEntity =>
        entityDatas.update(swappedEntity, entityData);
      };
    }
    def getComponent[T](entity) = {
      resume {
        do getComponent(entity)
      }
    }
    def setComponent[T](entity, value) = {
      resume {
        do setComponent(entity, value);
      }
    }
  }
}

def queryManager() { prog: => Unit / QueryManager }: Unit / ArchManager = {
  def addC[A, T, With, Without](
    query: Query[T, With, Without] at { global, io }
  ): Query[(T, A), With, Without] at { global, io } = {
    new Query[(T, A), With, Without] {
      def addC[C]() = {
        addC[C, (T, A), With, Without]()            
      }
      def withC[C]() = {
        withC[C, T, (With, A), Without]()            
      }
      def withoutC[C]() = {
        withoutC[C, T, With, (Without, A)]()            
      }
      def getWithWithoutIds() = {
        (withIds, withoutIds)
      }
    }
  }
  try {
    prog();
  } with QueryManager {
    def query[T]() = {
      val compId = do getComponentId();
      var matchingArchIds = resizableArray(0);
      var lastChangeVersion = 0;
      val withIds = emptyMap();
      val withoutIds = emptyMap();
      withIds.update(compId, ());
      def iterRO() { prog: => Unit / read[T] }: Unit / stop = {
        (do getQueryArchIds(withIds, withIds, lastChangeVersion)).map() { (matches, changeVersion) =>
          matchingArchIds = matches;
          lastChangeVersion = changeVersion;
        };
        matchingArchIds.foreach() { archId =>
          with iterComponentIndices
        };
        try {
          prog();
        } with read[T] {
        }
      }
      def iterRO() { prog: => Unit / { read[T], emit[T] } }: Unit / stop = {
        (do getQueryArchIds(withIds, withIds, lastChangeVersion)).map() { (matches, changeVersion) =>
          matchingArchIds = matches;
          lastChangeVersion = changeVersion;
        };
      }
      resume(
        new Query[T, Unit, Unit] {
          def addC[C]() = {
            addC[C, T, Unit, Unit]()            
          }
          def withC[C]() = {
            withC[C, T, Unit, Unit]()            
          }
          def withoutC[C]() = {
            withoutC[C, T, Unit, Unit]()            
          }
          def foreachRO() { action } = {
          }
          def foreachRW() { action } = {
            ()
          }
          def iterRO() { prog } = {
            iterRO() { prog };
          }
          def iterRW( prog ) = {
            iterRW() { prog };
          }
          def getWithWithoutIds() = {
            (withIds, withoutIds)
          }
        }
      )
    }
  }
}

def world() { prog: => Unit / { Resource[RunWorld], World } }: Unit = {
  with createResource[RunWorld](RunWorld(true));
  with componentManager();
  with archManager();
  with entityIdManager();
  with val entityDatas = entityManager();
  with queryManager();
  var system = new System {
    def step() = {
      ()
    }
  };
  def stepWorld() = {
    system.step();
  }
  try {
    prog();
  } with World {
    def stepWorld() = {
      resume {
        stepWorld();
      }
    }
    def runWorld() = {
      resume {
        loop { { l } =>
          if (not((do getResource[RunWorld]()).run)) {
            l.break();
          }
          // TEMP: Slightly longer runtime before memory crash
          wait(10);
          //wait(0);
          stepWorld();
        }
      }
    }
    def addSystem() = {
      resume { { body } =>
        system = new System {
          def step() = {
            system.step();
            systemEntityManager(entityDatas) {
              body();
            };
          }
        }
      }
    }
  }
}