module ecs

import array
import resizable_array
import mutable/map
import io
import io/time
import stream

import game_engine_lib/core

record Entity(id: Int)
record EntityData(archId: Int, entityIndex: Int)
record EntityInfo(entity: Entity, data: EntityData)

record ComponentStore[T](values: ResizableArray[Option[T]], freeIndices: ResizableArray[Int])

record Arch(componentIndices: Map[Int, ResizableArray[Int]], entities: ResizableArray[Entity])

// Resource to signal world loop exit
record RunWorld(run: Bool)

interface ComponentManager {
  def registerComponentStore[T](componentStore: Ref[ComponentStore[T]]): Int
  def removeComponent(componentId: Int, componentIndex: Int): Unit
  def copyComponent(componentId: Int, fromComponentIndex: Int, toComponentIndex: Int): Unit
}

interface Component[T] {
  def getComponentId(): Int
  def addComponent(value: T): Int
  def getComponent(index: Int): T
  def setComponent(index: Int, value: T): Unit
}

interface Resource[T] {
  def getResource(): T
  def setResource(value: T): Unit
}

interface ArchManager {
  def hasComponent(archId: Int, componentId: Int): Bool
  def addEntity(entity: Entity): EntityData
  def removeSwapEntity(archId: Int, entityIndex: Int): Option[EntityInfo]
  def getComponent[T](archId: Int, entityIndex: Int): T / Component[T]
  def setComponent[T](archId: Int, entityIndex: Int, value: T): Unit / Component[T]
  def addComponent[T](archId: Int, entityIndex: Int, value: T): (EntityInfo, Option[EntityInfo]) / Component[T]
  def addExistingComponent(archId: Int, entityIndex: Int, componentId: Int, componentIndex: Int): (EntityInfo, Option[EntityInfo])
  def removeComponent(archId: Int, entityIndex: Int, componentId: Int): (EntityInfo, Option[EntityInfo])
  def iterEntities(archId: Int) { prog: => Unit / read[Entity] }: Unit / stop
  def iterComponentIndices(archId: Int, componentId: Int) { prog: => Unit / read[Int] }: Unit / stop
  def getQueryArchIds(lastChangeVersion: Int, withIds: Map[Int, Unit], withoutIds: Map[Int, Unit]): Option[ResizableArray[Int]]
}

interface EntityManager {
  def hasEntity(entity: Entity): Bool
  def hasComponent(entity: Entity, componentId: Int): Bool
  def createEntity(): Entity
  def destroyEntity(entity: Entity): Unit
  def addComponent[T](entity: Entity, value: T): Unit / Component[T]
  def removeComponent[T](entity: Entity): Unit / Component[T]
  def getComponent[T](entity: Entity): T / Component[T]
  def setComponent[T](entity: Entity, value: T): Unit / Component[T]
}

interface Query[T, With, Without] {
  def foreachRO() { action: (Entity, T) => Unit }: Unit
  def foreachRW() { action: (Entity, T) => T }: Unit
}

interface QueryManager {
  def query(): Query[Unit, Unit, Unit] at { global, io } 
}

interface System {
  def step(): Unit / EntityManager
}

interface World {
  def stepWorld(): Unit / System
  def runWorld(): Unit / System
  def addSystem() { body: => Unit / EntityManager }: Unit
  def hasEntity(entity: Entity): Bool
  def hasComponent(entity: Entity, componentId: Int): Bool
  def createEntity(): Entity
  def destroyEntity(entity: Entity): Unit
  def addComponent[T](entity: Entity, value: T): Unit / Component[T]
  def removeComponent[T](entity: Entity): Unit / Component[T]
  def getComponent[T](entity: Entity): T / Component[T]
  def setComponent[T](entity: Entity, value: T): Unit / Component[T]
  def getQueryArchIds(lastChangeVersion: Int, withIds: Map[Int, Unit], withoutIds: Map[Int, Unit]): Option[ResizableArray[Int]]
  def query(): Query[Unit, Unit, Unit] at { global, io } 
}

def emptyComponentStore[T](): ComponentStore[T] = {
  ComponentStore(resizableArray(4), resizableArray(4))
}

def componentManager() { prog: => Unit / ComponentManager }: Unit = {
  var removeFuns: ResizableArray[Int => Unit at { global, io }] = resizableArray(4);
  var copyFuns: ResizableArray[(Int, Int) => Unit at { global, io }] = resizableArray(4);
  try {
    prog();
  } with ComponentManager {
    def registerComponentStore[T](componentStore) = {
      removeFuns.add(box { (componentIndex: Int) =>
        componentStore.get().values.unsafeSet(componentIndex, None());
        componentStore.get().freeIndices.add(componentIndex);
        ()
      });
      copyFuns.add(box { (fromComponentIndex: Int, toComponentIndex: Int) =>
        val values = componentStore.get().values;
        values.unsafeSet(toComponentIndex, values.unsafeGet(fromComponentIndex));
        ()
      });
      resume(removeFuns.size() - 1)
    }
    def removeComponent(componentId, componentIndex) = {
      (removeFuns.unsafeGet(componentId))(componentIndex);
      resume(())
    }
    def copyComponent(componentId, fromComponentIndex, toComponentIndex) = {
      (copyFuns.unsafeGet(componentId))(fromComponentIndex, toComponentIndex);
      resume(())
    }
  }
}

def component[T]() { prog: => Unit / Component[T] }: Unit / ComponentManager = {
  val componentStore = ref(emptyComponentStore());
  val componentId = do registerComponentStore(componentStore);
  try {
    prog();
  } with Component[T] {
    def getComponentId() = {
      resume((componentId))
    }
    def addComponent(value) = {
      resume(componentStore.get().add(Some(value)))
    }
    def getComponent(index) = {
      val value = componentStore.get().values.unsafeGet(index).getOrElse() {
        panic("Component[T] getComponent called on empty (None) index!");
      };
      resume(value)
    }
    def setComponent(index, value) = {
      componentStore.get().values.unsafeSet(index, Some(value));
      resume(())
    }
  }
}

def createResource[T](value: T) { prog: => Unit / Resource[T] }: Unit = {
  var resourceValue = value;
  try {
    prog();
  } with Resource[T] {
    def getResource() = {
      resume(resourceValue)
    }
    def setResource(value) = {
      resourceValue = value;
      resume(())
    }
  }
}

def archManager() { prog: => Unit / ArchManager }: Unit / ComponentManager = {
  val archs = optionArray(4);
  archs.add(Arch(emptyMap(), resizableArray(4)));
  var changeVersion = 1;
  def addArch(arch: Arch): Int = {
    changeVersion = changeVersion + 1;
    archs.add(arch)
  }
  def removeArch(archId: Int) = {
    changeVersion = changeVersion + 1;
    archs.remove(archId);
  }
  def getMatchingArchId(componentIds: Array[Int]): Option[Int] = {
    var matching = None();
    archs.arr.foreachIndex() { (i, archOpt) { l } =>
      archOpt match {
        case Some(arch) => {
          if (arch.componentIndices.containsOnlyAll(componentIds)) {
            matching = Some(i);
            l.break();
          }
          ()
        }
        case None() => ()
      }
    };
    matching
  }
  def removeSwapEntityIndices(arch: Arch, entityIndex: Int): Option[Int] = {
    val swapped = arch.entities.removeSwap(entityIndex);
    arch.componentIndices.values().foreach() { indices =>
      indices.removeSwap(entityIndex);
    };
    swapped
  }
  def getComponent[T](archId: Int, entityIndex: Int): T / Component[T] = {
    val compId = do getComponentId();
    val compIndex = archs.unsafeGet(archId).componentIndices.unsafeGet(compId).unsafeGet(entityIndex);
    do getComponent(compIndex)
  }
  def setComponent[T](archId: Int, entityIndex: Int, value: T): Unit / Component[T] = {
    val compId = do getComponentId();
    val compIndex = archs.unsafeGet(archId).componentIndices.unsafeGet(compId).unsafeGet(entityIndex);
    do setComponent(compIndex, value);
  }
  def addExistingComponent(archId: Int, entityIndex: Int, componentId: Int, componentIndex: Int): (EntityInfo, Option[EntityInfo]) = {
    val oldArch = archs.unsafeGet(archId);
    val newCompIndices = emptyMap();
    var sameArch = false;
    oldArch.componentIndices.keys().foreach() { (compId) { l } =>
      if (compId == componentId) {
        sameArch = true;
        l.break();
      }
      newCompIndices.update(compId, resizableArray(0));
    };
    newCompIndices.update(componentId, resizableArray(0));
    if (sameArch) {
      val oldComponentIndex = oldArch.componentIndices.unsafeGet(componentId).unsafeGet(entityIndex);
      do copyComponent(componentId, componentIndex, oldComponentIndex);
      do removeComponent(componentId, componentIndex);
      (
        EntityInfo(oldArch.entities.unsafeGet(entityIndex), EntityData(archId, entityIndex)),
        None()
      )
    } else {
      val newArchId = getMatchingArchId(newCompIndices.keys()) match {
        case Some(newArchId) => newArchId
        case None() => addArch(Arch(newCompIndices, resizableArray(4)))
      };
      val newArch = archs.unsafeGet(newArchId);
      val newEntityIndex = newArch.entities.add(oldArch.entities.unsafeGet(entityIndex));
      oldArch.componentIndices.keys().foreach() { compId =>
        newArch.componentIndices.unsafeGet(compId).add(oldArch.componentIndices.unsafeGet(compId).unsafeGet(entityIndex));
      };
      newArch.componentIndices.unsafeGet(componentId).add(componentIndex);
      val swappedInfo = oldArch.removeSwapEntityIndices(entityIndex) match {
        case Some(_) => Some(EntityInfo(oldArch.entities.unsafeGet(entityIndex), EntityData(archId, entityIndex)))
        case None() => None()
      };
      if (archId > 0 && oldArch.entities.size() == 0) {
        removeArch(archId);
      }
      (
        EntityInfo(newArch.entities.unsafeGet(newEntityIndex), EntityData(newArchId, newEntityIndex)),
        swappedInfo
      )
    }
  }
  try {
    prog();
  } with ArchManager {
    def hasComponent(archId, componentId) = {
      archs.unsafeGet(archId).componentIndices.get(componentId).isDefined()
    }
    def addEntity(entity) = {
      resume(EntityData(0, archs.unsafeGet(0).entities.add(entity)))
    }
    def removeSwapEntity(archId, entityIndex) = {
      val arch = archs.unsafeGet(archId);
      arch.componentIds.foreach() { compId =>
        val compIndex = arch.componentIndices.unsafeGet(compId).unsafeGet(entityIndex);
        do removeComponent(compId, compIndex);
      };
      val swappedInfo = arch.removeSwapEntityIndices(entityIndex) match {
        case Some(index) => Some(EntityInfo(arch.entities.unsafeGet(index), EntityData(archId, index)))
        case None() => None()
      };
      if (archId > 0 && arch.entities.size() == 0) {
        removeArch(archId);
      }
      swappedInfo
    }
    def getComponent[T](archId, entityIndex) = {
      resume {
        getComponent(archId, entityIndex)
      }
    }
    def setComponent[T](archId, entityIndex, value) = {
      resume {
        setComponent(archId, entityIndex, value);
      }
    }
    def addComponent[T](archId, entityIndex, value) = {
      resume {
        addExistingComponent(archId, entityIndex, compId, do addComponent(value));
      }
    }
    def addExistingComponent(archId, entityIndex, componentId, componentIndex) = {
      resume(addExistingComponent(archId, entityIndex, componentId, componentIndex))
    }
    def removeComponent(archId, entityIndex, componentId) = {
      val oldArch = archs.unsafeGet(archId);
      val newCompIndices = emptyMap();
      var sameArch = true;
      oldArch.componentIndices.keys().foreach() { compId =>
        if (compId == componentId) {
          sameArch = false;
        } else {
          newCompIndices.update(compId, resizableArray(0));
        }
      };
      if (sameArch) {
        (
          EntityInfo(oldArch.entities.unsafeGet(entityIndex), EntityData(archId, entityIndex)),
          None()
        )
      } else {
        val newCompIds = newCompIndices.keys();
        val newArchId = getMatchingArchId(newCompIds) match {
          case Some(newArchId) => newArchId
          case None() => addArch(Arch(newCompIndices, resizableArray(4)))
        };
        val newArch = archs.unsafeGet(newArchId);
        val newEntityIndex = newArch.entities.add(oldArch.entities.unsafeGet(entityIndex));
        newCompIds.foreach() { compId =>
          newArch.componentIndices.unsafeGet(compId).add(oldArch.componentIndices.unsafeGet(compId).unsafeGet(entityIndex));
        };
        do removeComponent(componentId, oldArch.componentIndices.unsafeGet(componentId).unsafeGet(entityIndex));
        val swappedInfo = oldArch.removeSwapEntityIndices(entityIndex) match {
          case Some(_) => Some(EntityInfo(oldArch.entities.unsafeGet(entityIndex), EntityData(archId, entityIndex)))
          case None() => None()
        };
        if (archId > 0 && oldArch.entities.size() == 0) {
          removeArch(archId);
        }
        (
          EntityInfo(newArch.entities.unsafeGet(newEntityIndex), EntityData(newArchId, newEntityIndex)),
          swappedInfo
        )
      }
    }
    def iterEntities(archId) = {
      resume { { prog } =>
        val entities = archs.unsafeGet(archId).entities;
        var index = 0;
        try {
          prog();
        } with read[Entity] {
          resume {
            if (index < entities.size()) {
              index = index + 1;
              entities.unsafeGet(index - 1)
            } else {
              do stop()
            }
          }
        }
      }
    }
    def iterComponentIndices(archId, componentId) = {
      resume { { prog } =>
        val componentIndices = archs.unsafeGet(archId).componentIndices.unsafeGet(componentId);
        var index = 0;
        try {
          prog();
        } with read[Int] {
          resume {
            if (index < componentIndices.size()) {
              index = index + 1;
              componentIndices.unsafeGet(index - 1)
            } else {
              do stop()
            }
          }
        }
      }
    }
    def getQueryArchIds(lastChangeVersion, withIds, withoutIds) = {
      if (lastChangeVersion < changeVersion) {
        val matching = resizableArray(4);
        archs.arr.foreachIndex() { (i, archOpt)
          archOpt match {
            case Some(arch) => {
              val archCompIds = arch.componentIndices;
              if (archCompIds.containsAll(withIds.keys()) && archCompIds.containsNone(withoutIds.keys())) {
                matching.add();
              }
              ()
            }
            case None() => ()
          }
        };
        Some(matching)
      } else {
        None()
      }
    }
  }
}

def entityManager() { prog: => Unit / EntityManager }: Unit / ArchManager = {
  var entityDatas: Map[Int, EntityData] = emptyMap();
  var lastEntityId = 0;
  def nextEntityId() = {
    lastEntityId = lastEntityId + 1;
    lastEntityId
  }
  try {
    prog();
  } with EntityManager {

  }
}

def systemEntityManager() { prog: => Unit / EntityManager }: Unit / EntityManager = {
  try {
    prog();
  } with EntityManager {

  }
}

def queryManager() { prog: => Unit / QueryManager }: Unit / ArchManager = {
  try {
    prog();
  } with QueryManager {
    def query() = {
      new Query[Unit, Unit, Unit] {

      }
    }
  }
}

def world() { prog: => Unit / { Resource[RunWorld], World } }: Unit = {
  with createResource[RunWorld](RunWorld(true));
  with componentManager();
  with archManager();
  with entityManager();
  with queryManager();
  var system = new System {
    def step() = {
      ()
    }
  };
  def stepWorld() = {
    system.step();
  }
  try {
    prog();
  } with World {
    def stepWorld() = {
      resume {
        stepWorld();
      }
    }
    def runWorld() = {
      resume {
        loop { { l } =>
          if (not((do getResource[RunWorld]()).run)) {
            l.break();
          }
          // TEMP: Slightly longer runtime before memory crash
          wait(10);
          //wait(0);
          stepWorld();
        }
      }
    }
    def addSystem() = {
      resume { { body } =>
        system = new System {
          def step() = {
            system.step();
            systemEntityManager() {
              body();
            };
          }
        }
      }
    }
    def hasEntity(entity) = {
      resume(do hasEntity(entity))
    }
    def hasComponent(entity, componentId) = {
      resume(do hasComponent(entity, componentId))
    }
    def createEntity() = {
      resume(do createEntity())
    }
    def destroyEntity(entity) = {
      do destroyEntity(entity);
      resume(())
    }
    def addComponent[T](entity, value) = {
      resume {
        do addComponent(entity, value);
      }
    }
    def removeComponent[T](entity) = {
      resume {
        do removeComponent(entity);
      }
    }
    def getComponent[T](entity) = {
      resume {
        do getComponent(entity)
      }
    }
    def setComponent[T](entity, value) = {
      resume {
        do setComponent(entity, value);
      }
    }
    def getQueryArchIds(lastChangeVersion, withIds, withoutIds) = {
      resume(do getQueryArchIds(lastChangeVersion, withIds, withoutIds))
    }
    def query() = {
      resume(do query())
    }
  }
}