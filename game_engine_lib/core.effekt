import mutable/map
import resizable_array

// Map delete extension
extern js """
function map$delete(m, key) {
  m.delete(key);
  return $effekt.unit
}
"""

extern io def delete[K, V](m: Map[K, V], key: K): Unit =
  js "map$delete(${m}, ${key})"

def removeSwap[T](arr: ResizableArray[T], index: Int): Option[Int] / Exception[OutOfBounds] = {
  val newSize = arr.size() - 1;
  var swapped = None();
  if (index < newSize) {
    arr.unsafeSet(index, arr.unsafeGet(newSize));
    swapped = Some(newSize);
  }
  arr.popRight();
  swapped
}

interface Iterator[T] {
  def next(): Option[T]
  def setLastValue(value: T): Unit
  def reset(): Unit
}

record IterResizableArray[T](arr: ResizableArray[T], nextIndex: Ref[Int])

def iterate[T](arr: ResizableArray[T]): IterResizableArray[T] = {
  IterResizableArray(arr, ref(0))
}

def next[T](iter: IterResizableArray[T]): Option[T] = {
  val i = iter.nextIndex.get();
  if (i < iter.arr.size()) {
    iter.nextIndex.set(i + 1);
    Some(iter.arr.unsafeGet(i))
  } else {
    None()
  }
}

def setLastValue[T](iter: IterResizableArray[T], value: T) = {
  val i = iter.nextIndex.get() - 1;
  if (i >= 0 && i < iter.arr.size()) {
    iter.arr.unsafeSet(i, value)
  }
}

def reset[T](iter: IterResizableArray[T]) = {
  iter.nextIndex.set(0)
}

def iterator[T](arr: ResizableArray[T]) { prog: => Unit / Iterator[T] }: Unit / {} = {
  val iter = arr.iterate();
  try {
    prog();
  } with Iterator[T] {
    def next() = {
      resume(iter.next())
    }
    def setLastValue(value: T) = {
      iter.setLastValue(value);
      resume(())
    }
    def reset() = {
      iter.reset();
      resume(())
    }
  }
}

record IterChainResizableArray[T](arr: ResizableArray[IterResizableArray[T]], nextIndex: Ref[Int])

def iterate[T](arr: ResizableArray[IterResizableArray[T]]): IterChainResizableArray[T] = {
  IterChainResizableArray(arr, ref(0))
}

def next[T](iter: IterChainResizableArray[T]): Option[T] = {
  var i = iter.nextIndex.get();
  if (i < iter.arr.size()) {
    var value = iter.arr.unsafeGet(i).next();
    while (value.isEmpty() && i + 1 < iter.arr.size()) {
      i = i + 1;
      value = iter.arr.unsafeGet(i).next();
    }
    value
  } else {
    None()
  }
}

def setLastValue[T](iter: IterChainResizableArray[T], value: T) = {
  var i = iter.nextIndex.get();
  if (i < iter.arr.size()) {
    iter.arr.unsafeGet(i).setLastValue(value);
  }
}

def reset[T](iter: IterChainResizableArray[T]) = {
  iter.nextIndex.set(0);
  iter.arr.foreach() { x =>
    x.reset();
  }
}

def iteratorChain[T](arr: ResizableArray[IterResizableArray[T]]) { prog: => Unit / Iterator[T] }: Unit / {} = {
  val iter: IterChainResizableArray[T] = arr.iterate();
  try {
    prog();
  } with Iterator[T] {
    def next() = {
      resume(iter.next())
    }
    def setLastValue(value: T) = {
      iter.setLastValue(value);
      resume(())
    }
    def reset() = {
      iter.reset();
      resume(())
    }
  }
}

def foreachRef[A]() { body: (
  Ref[A]
) => Unit }: Unit / {
  Iterator[A]
} = {
  do reset[A]();
  val refA = allocate();
  loop { { l } =>
    do next[A]() match {
      case Some(a) => {
        refA.set(a);
        body(
          refA
        );
        do setLastValue(refA.get());
      }
      case _ => {
        l.break();
      }
    }
  }
}

def foreachRef[A, B]() { body: (
  Ref[A],
  Ref[B]
) => Unit }: Unit / {
  Iterator[A],
  Iterator[B]
} = {
  do reset[A]();
  do reset[B]();
  val refA = allocate();
  val refB = allocate();
  loop { { l } =>
    (
      do next[A](),
      do next[B]()
    ) match {
      case (
        Some(a),
        Some(b)
      ) => {
        refA.set(a);
        refB.set(b);
        body(
          refA,
          refB
        );
        do setLastValue(refA.get());
        do setLastValue(refB.get());
      }
      case _ => {
        l.break();
      }
    }
  }
}

def foreachRef[A, B, C]() { body: (
  Ref[A],
  Ref[B],
  Ref[C]
) => Unit }: Unit / {
  Iterator[A],
  Iterator[B],
  Iterator[C]
} = {
  do reset[A]();
  do reset[B]();
  do reset[C]();
  val refA = allocate();
  val refB = allocate();
  val refC = allocate();
  loop { { l } =>
    (
      do next[A](),
      do next[B](),
      do next[C]()
    ) match {
      case (
        Some(a),
        Some(b),
        Some(c)
      ) => {
        refA.set(a);
        refB.set(b);
        refC.set(c);
        body(
          refA,
          refB,
          refC
        );
        do setLastValue(refA.get());
        do setLastValue(refB.get());
        do setLastValue(refC.get());
      }
      case _ => {
        l.break();
      }
    }
  }
}

def foreachRef[A, B, C, D]() { body: (
  Ref[A],
  Ref[B],
  Ref[C],
  Ref[D]
) => Unit }: Unit / {
  Iterator[A],
  Iterator[B],
  Iterator[C],
  Iterator[D]
} = {
  do reset[A]();
  do reset[B]();
  do reset[C]();
  do reset[D]();
  val refA = allocate();
  val refB = allocate();
  val refC = allocate();
  val refD = allocate();
  loop { { l } =>
    (
      do next[A](),
      do next[B](),
      do next[C](),
      do next[D]()
    ) match {
      case (
        Some(a),
        Some(b),
        Some(c),
        Some(d)
      ) => {
        refA.set(a);
        refB.set(b);
        refC.set(c);
        refD.set(d);
        body(
          refA,
          refB,
          refC,
          refD
        );
        do setLastValue(refA.get());
        do setLastValue(refB.get());
        do setLastValue(refC.get());
        do setLastValue(refD.get());
      }
      case _ => {
        l.break();
      }
    }
  }
}

record Vector2(x: Double, y: Double)

def setX(v: Vector2, d: Double): Vector2 = {
  Vector2(d, v.y)
}

def setY(v: Vector2, d: Double): Vector2 = {
  Vector2(v.x, d)
}

def infixAdd(v1: Vector2, v2: Vector2): Vector2 = {
  Vector2(v1.x + v2.x, v1.y + v2.y)
}

def infixAdd(v: Vector2, d: Double): Vector2 = {
  Vector2(v.x + d, v.y + d)
}

def infixSub(v1: Vector2, v2: Vector2): Vector2 = {
  Vector2(v1.x - v2.x, v1.y - v2.y)
}

def infixSub(v: Vector2, d: Double): Vector2 = {
  Vector2(v.x - d, v.y - d)
}

def infixMul(v: Vector2, d: Double): Vector2 = {
  Vector2(v.x * d, v.y * d)
}

// Scalar (dot) product
def infixMul(v1: Vector2, v2: Vector2): Double = {
  v1.x * v2.x + v1.y * v2.y
}

def infixDiv(v: Vector2, d: Double): Vector2 = {
  Vector2(v.x / d, v.y / d)
}

def length(v: Vector2): Double = {
  sqrt(v.x * v.x + v.y * v.y)
}

def normalize(v: Vector2): Vector2 = {
  val l = v.length();
  if (l == 0.0) {
    Vector2(0.0, 0.0)
  } else {
    v / l
  }
}

def round(v: Vector2): Vector2 = {
  Vector2(round(v.x).toDouble, round(v.y).toDouble)
}

def ceil(v: Vector2): Vector2 = {
  Vector2(ceil(v.x).toDouble, ceil(v.y).toDouble)
}

def floor(v: Vector2): Vector2 = {
  Vector2(floor(v.x).toDouble, floor(v.y).toDouble)
}

record Vector2Int(x: Int, y: Int)

def setX(v: Vector2Int, d: Int): Vector2Int = {
  Vector2Int(d, v.y)
}

def setY(v: Vector2Int, d: Int): Vector2Int = {
  Vector2Int(v.x, d)
}

def toVector2(v: Vector2Int): Vector2 = {
  Vector2(v.x.toDouble(), v.y.toDouble())
}

def infixAdd(v1: Vector2Int, v2: Vector2Int): Vector2Int = {
  Vector2Int(v1.x + v2.x, v1.y + v2.y)
}

def infixAdd(v: Vector2Int, d: Int): Vector2Int = {
  Vector2Int(v.x + d, v.y + d)
}

def infixSub(v1: Vector2Int, v2: Vector2Int): Vector2Int = {
  Vector2Int(v1.x - v2.x, v1.y - v2.y)
}

def infixSub(v: Vector2Int, d: Int): Vector2Int = {
  Vector2Int(v.x - d, v.y - d)
}

def infixMul(v: Vector2Int, d: Int): Vector2Int = {
  Vector2Int(v.x * d, v.y * d)
}

// Scalar (dot) product
def infixMul(v1: Vector2Int, v2: Vector2Int): Int = {
  v1.x * v2.x + v1.y * v2.y
}

def infixDiv(v: Vector2Int, d: Int): Vector2Int = {
  Vector2Int(v.x / d, v.y / d)
}

def length(v: Vector2Int): Double = {
  sqrt((v.x * v.x + v.y * v.y).toDouble)
}

def normalize(v: Vector2Int): Vector2 = {
  val l = v.length();
  if (l == 0.0) {
    Vector2(0.0, 0.0)
  } else {
    v.toVector2() / l
  }
}

def round(v: Vector2): Vector2Int = {
  Vector2Int(round(v.x), round(v.y))
}

def ceil(v: Vector2): Vector2Int = {
  Vector2Int(ceil(v.x), ceil(v.y))
}

def floor(v: Vector2): Vector2Int = {
  Vector2Int(floor(v.x), floor(v.y))
}

record Color(r: Int, g: Int, b: Int)

def setR(c: Color, i: Int): Color = {
  Color(i, c.g, c.b)
}

def setG(c: Color, i: Int): Color = {
  Color(c.r, i, c.b)
}

def setB(c: Color, i: Int): Color = {
  Color(c.r, c.g, i)
}