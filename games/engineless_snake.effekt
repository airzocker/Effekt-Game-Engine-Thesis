module engineless_snake

import io/time

def runSnake() = {
  // Color constants
  val wallColor = "rgb(100 98 105)";
  val backgroundColor = "rgb(200 180 50)";
  val headColor = "rgb(40 40 180)";
  val tailColor = "rgb(60 200 50)";
  val appleColor = "rgb(240 40 20)";
  val textColor = "rgb(240 240 240)";

  // Game constants
  val gridSize = 35;
  val gridOffset = 0.5 - gridSize.toDouble() * 0.5;
  val wallSize = 1.5;
  val moveTime = 0.1;
  val scoreFontSize = (7.0 / 8.0) * wallSize;
  val gameOverTextScale = 1.0 / 12.0;

  // Game state
  var windowW = 1;
  var windowH = 1;
  var gameOver = false;
  var headPosX = gridSize / 2;
  var headPosY = gridSize / 2;
  var headDirX = 0;
  var headDirY = 1;
  var lastMoveDirX = headDirX;
  var lastMoveDirY = headDirY;
  val tailParts: List[(Int, Int)] = [];
  var appleX = 0;
  var appleY = 0;
  var scoreX = wallSize * 1.5 - 0.5;
  var scoreY = (gridSize.toDouble() - 0.5) + wallSize * 0.5;

  def gameToWindow(x: Double, y: Double) = {
    val smallerSide = if (windowH > windowW) {
      windowW.toDouble()
    } else {
      windowH.toDouble()
    };
    val pixelsPerUnit = smallerSide / (gridSize.toDouble() + wallSize * 2.0);
    (
      (x + wallSize + 0.5) * pixelsPerUnit,
      windowH.toDouble() - ((y + wallSize + 0.5) * pixelsPerUnit)
    )
  }

  def setGameOver() = {
    gameOver = true;
    scoreX = 0.0 - gridOffset;
    scoreY = (0.0 - gridOffset) - gridSize.toDouble() * gameOverTextScale;
  }

  def newApple() = {
    var foundPos = false;
    each(0, gridSize * gridSize) { (_) { l } =>
      appleX = jsRandomInt(0, gridSize);
      appleY = jsRandomInt(0, gridSize);
      if (headPosX == appleX || headPosY == appleY) {
        l.continue();
      }
      tailParts.foreach() { tail =>
        if (tail.first == appleX || tail.second == appleY) {
          l.continue();
        }
      };
      foundPos = true;
      l.break();
    }
    if (not(foundPos)) {
      appleY = -10000;
      setGameOver();
    }
  }

  def gameLoop() = {
    windowW = jsGetCanvasWidth();
    windowH = jsGetCanvasHeight();

    if (jsGetKey("ArrowUp") && lastMoveDirY == 0) {
      headDirX = 0;
      headDirY = 1;
    } else if (jsGetKey("ArrowDown") && lastMoveDirY == 0) {
      headDirX = 0;
      headDirY = -1;
    } else if (jsGetKey("ArrowRight") && lastMoveDirX == 0) {
      headDirX = 1;
      headDirY = 0;
    } else if (jsGetKey("ArrowLeft") && lastMoveDirX == 0) {
      headDirX = -1;
      headDirY = 0;
    }

    // TODO: Update timer, head, tails, apple, collisions

    // TODO: Draw

    ()
  }

  loop { { l } =>
    gameLoop();
    wait(10);
    if (gameOver || jsGetKey("Escape")) {
      l.break();
    }
  }

  ()
}

def enginelessSnake() = {
  jsInitCanvas();
  jsInitInput();
  loop { { runLoop } =>
    runSnake();
    loop { { keyLoop } =>
      if (jsGetKey("Enter")) {
        runLoop.continue();
      }
      if (jsGetKey("Escape")) {
        keyLoop.break();
      }
    }
    runLoop.break();
  }
}

extern type CanvasRenderingContext2D

extern pure def jsGetTime(): Double =
  js "window.performance.now() / 1000.0"

extern io def jsInitCanvas(): Unit =
  js "initCanvas()"

extern io def jsInitInput(): Unit =
  js "initInput()"

extern pure def jsGetCanvasWidth(): Int =
  js "canvas.width"

extern pure def jsGetCanvasHeight(): Int =
  js "canvas.height"

extern pure def jsGetContext(): CanvasRenderingContext2D =
  js "canvas.getContext('2d')"

extern io def jsClearCanvas(context: CanvasRenderingContext2D): Unit =
  js "clearCanvas(${context})"

extern io def jsFillStyle(context: CanvasRenderingContext2D, color: String): Unit =
  js "(${context}).fillStyle = ${color}"

extern io def jsFillRect(context: CanvasRenderingContext2D, x: Int, y: Int, w: Int, h: Int): Unit =
  js "(${context}).fillRect(${x}, ${y}, ${w}, ${h})"

extern io def jsInitFont(context: CanvasRenderingContext2D, fontSize: Int): Unit =
  js "initFont(${context}, ${fontSize})"

extern io def jsFillText(context: CanvasRenderingContext2D, text: String, x: Int, y: Int, fontSize: Int): Unit =
  js "(${context}).fillText(${text}, ${x}, ${y} + 0.36 * ${fontSize})"

extern pure def jsGetKey(keyCode: String): Bool =
  js "getKey(${keyCode})"

// Random Int [min, max)
extern pure def jsRandomInt(min: Int, max: Int): Int =
  js "Math.floor(Math.random() * (${max} - ${min})) + ${min}"

extern js """

const keySet = new Set();

let canvas = null;

function initCanvas() {
  document.head.innerHTML += `
    <style>
    html, body, canvas { padding: 0; margin: 0; }
    canvas { display:block; }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Effekt Game Engine</title>
  `;
  document.body.innerHTML += `
    <canvas id="myCanvas" width="640" height="360"></canvas>
  `;
  canvas = document.getElementById('myCanvas');
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
}

function initInput() {
  window.addEventListener('keydown', onKeyDown, true);
  window.addEventListener('keyup', onKeyUp, true);
}

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

function onKeyDown(event) {
  keySet.add(event.code);
}

function onKeyUp(event) {
  keySet.delete(event.code);
}

function getKey(keyCode) {
  return keySet.has(keyCode);
}

function initFont(context, fontSize) {
  context.font = 'bold ' + fontSize + 'px sans';
  context.textAlign = 'center';
}

function clearCanvas(context) {
  context.fillStyle = "rgb(0 0 0)";
  context.fillRect(0, 0, canvas.width, canvas.height);
}

"""