module snake_game

import game_engine_lib/math
import game_engine_lib/core
import game_engine_lib/ecs
import game_engine_lib/engine
import game_engine_lib/canvas_renderer
import game_engine_lib/input

// Components
record SnakeTag()
record MoveDir(next: Vector2Int, last: Vector2Int)
record LastPosition(value: Vector2)
record NextTail(value: Entity)

// Resouces
record GameOver(value: Bool)
record ResetGame(value: Bool)
record MoveTimer(moveTimer: Double, doMove: Bool)
record Head(value: Entity)
record LastTail(value: Entity)
record Apple(value: Entity)

def snakeGame() = {
  // Color constants
  val backgroundColor = Color(200, 180, 50);
  val headColor = Color(40, 40, 180);
  val tailColor = Color(60, 200, 50);
  val appleColor = Color(240, 40, 20);

  // Game constants
  val gridSize = 50;
  val gridOffset = 0.5 - gridSize.toDouble() * 0.5;
  val moveTime = 0.1;
  //val startPos = uniform((gridSize / 2).toDouble());
  val startPos = Vector2(
    (gridSize / 2).toDouble(),
    (gridSize / 2).toDouble()
  );
  val startDir = Vector2Int(0, 1);

  // ECS & Engine init
  with engineWorld();
  with canvasRenderer();

  // Our components
  with component[SnakeTag]();
  with component[MoveDir]();
  with component[LastPosition]();
  with component[NextTail]();
  
  // Our resources
  with createResource[GameOver](GameOver(false));
  with createResource[ResetGame](ResetGame(false));
  with createResource[MoveTimer](MoveTimer(0.0, false));
  with createResource[Head](Head(Entity(0)));
  with createResource[LastTail](LastTail(Entity(0)));
  with createResource[Apple](Apple(Entity(0)));

  // Needed component tuples
  with zipComponents2[SnakeTag, NextTail]();
  with zipComponents2[Position, MoveDir]();
  with zipComponents2[Position, NextTail]();
  with zipComponents2[Position, LastPosition]();
  with zipComponents2[Position, Shape]();
  with zipComponents3[Position, Scale, Shape]();
  with zipComponents5[Position, LastPosition, Shape, NextTail, SnakeTag]();
  with zipComponents5[Position, LastPosition, Shape, MoveDir, SnakeTag]();
  
  def initGame() = {
    // Resources
    do setResource[MoveTimer](MoveTimer(moveTime, false));

    // Background
    do createEntity[(Position, Scale, Shape)]((
      //Position(uniform(0.0 - gridOffset)),
      Position(Vector2(0.0 - gridOffset, 0.0 - gridOffset)),
      Scale(Vector2(gridSize.toDouble(), gridSize.toDouble())),
      Rect(backgroundColor)
    ));

    // Head
    val head = do createEntity[(Position, LastPosition, Shape, MoveDir, SnakeTag)]((
      Position(startPos),
      LastPosition(startPos),
      Rect(headColor),
      MoveDir(startDir, startDir),
      SnakeTag()
    ));
    do setResource[Head](Head(head));
    do setResource[LastTail](LastTail(head));
    
    // Apple
    var applePos: Vector2 = zero();
    each(0, gridSize * gridSize) { (_) { l } =>
      applePos = Vector2(jsRandomInt(0, gridSize).toDouble(), jsRandomInt(0, gridSize).toDouble());
      if (startPos == applePos) {
        l.continue();
      }
      l.break();
    }
    val apple = do createEntity[(Position, Shape)]((
      Position(applePos),
      Rect(appleColor)
    ));
    do setResource[Apple](Apple(apple));
  }

  // Update game dimensions from window size
  with addSystem[Unit, Unit, Unit]() { { _ } =>
    val windowSize = (do getResource[WindowProperties]()).size;
    var camHeight = gridSize.toDouble();
    if (windowSize.x < windowSize.y) {
      camHeight = gridSize.toDouble() * (windowSize.y.toDouble() / windowSize.x.toDouble());      
    }
    do setResource[Camera](Camera(
      Vector2(0.0 - gridOffset, 0.0 - gridOffset),
      0.0,
      camHeight
    ));
    ()
  };

  // Update move timer
  with addSystem[Unit, Unit, Unit]() { { _ } =>
    if (not((do getResource[GameOver]()).value)) {
      val deltaTime = (do getResource[Time]()).deltaTime;
      var moveTimer = (do getResource[MoveTimer]()).moveTimer - deltaTime;
      val doMove = moveTimer < 0.0;
      if (doMove) {
        moveTimer = moveTimer + moveTime;
        if (moveTimer < 0.0) {
          moveTimer = 0.0;
        }
      }
      do setResource[MoveTimer](MoveTimer(moveTimer, doMove));
    }
    ()
  };

  // Update head
  with addSystem[(Position, MoveDir), SnakeTag, Unit]() { { query } =>
    if (not((do getResource[GameOver]()).value)) {
      val doMove = (do getResource[MoveTimer]()).doMove;
      query.foreachRW() { (_, values) =>
        values match {
          case (position, moveDir) => {
            var newMoveDir = moveDir.next;
            if (jsGetKeyDown("ArrowUp") && moveDir.last.y == 0) {
              newMoveDir = Vector2Int(0, 1)
            } else if (jsGetKeyDown("ArrowDown") && moveDir.last.y == 0) {
              newMoveDir = Vector2Int(0, -1)
            } else if (jsGetKeyDown("ArrowRight") && moveDir.last.x == 0) {
              newMoveDir = Vector2Int(1, 0)
            } else if (jsGetKeyDown("ArrowLeft") && moveDir.last.x == 0) {
              newMoveDir = Vector2Int(-1, 0)
            }
            val newLastMoveDir = if (doMove) {
              newMoveDir
            } else {
              moveDir.last
            };
            val newPosition = if (doMove) {
              Position(Vector2(
                (position.value.x.round() + newMoveDir.x).toDouble(),
                (position.value.y.round() + newMoveDir.y).toDouble()
              ))
            } else {
              position
            };
            (
              newPosition,
              MoveDir(newMoveDir, newLastMoveDir)
            )
          }
        }
      };
    }
    ()
  };

  // Update tail
  with addSystem[(Position, NextTail), SnakeTag, Unit]() { { query } =>
    if (not((do getResource[GameOver]()).value)) {
      val doMove = (do getResource[MoveTimer]()).doMove;
      if (doMove) {
        query.foreachRW() { (_, values) =>
          values match {
            case (position, nextTail) => {
              val newPosition = (do getComponent[LastPosition](nextTail.value)).value;
              (Position(newPosition), nextTail)
            }
          }
        };
      }
    }
    ()
  };
  
  // Update apple
  // Query is on all snake parts to check for non-colliding placement
  with addSystem[Position, SnakeTag, Unit]() { { query } =>
    val doMove = (do getResource[MoveTimer]()).doMove;
    if (doMove) {
      val apple = (do getResource[Apple]()).value;
      val applePos = (do getComponent[Position](apple)).value;
      val headPos = (do getComponent[Position]((do getResource[Head]()).value)).value;
      if (headPos == applePos) {
        var newApplePos: Vector2 = zero();
        each(0, gridSize * gridSize) { (_) { l } =>
          newApplePos = Vector2(jsRandomInt(0, gridSize).toDouble(), jsRandomInt(0, gridSize).toDouble());
          query.foreachRO() { (_, position) =>
            if (position.value == newApplePos) {
              l.continue();
            }
          };
          l.break();
        }
        do setComponent[Position](apple, Position(newApplePos));
        // Add tail part
        val lastTail = (do getResource[LastTail]()).value;
        val tailPos = (do getComponent[LastPosition](lastTail)).value;
        val tail = do createEntity[(Position, LastPosition, Shape, NextTail, SnakeTag)]((
          Position(tailPos),
          LastPosition(tailPos),
          Rect(tailColor),
          NextTail(lastTail),
          SnakeTag()
        ));
        do setResource[LastTail](LastTail(tail));
      }
    }
    ()
  }

  // Detect head collisions
  // Query is on tail parts to check for head collision
  with addSystem[Position, (SnakeTag, NextTail), Unit]() { { query } =>
    def gameOver() = {
      do setResource[GameOver](GameOver(true));
    }
    if (not((do getResource[GameOver]()).value)) {
      val doMove = (do getResource[MoveTimer]()).doMove;
      if (doMove) {
        val headPos = (do getComponent[Position]((do getResource[Head]()).value)).value;
        if (headPos.x < -0.5 || headPos.y < -0.5 || headPos.x > gridSize.toDouble() - 0.5 || headPos.y > gridSize.toDouble() - 0.5) {
          gameOver();
        }
        query.foreachRO() { (_, position) =>
          if (headPos == position.value) {
            gameOver();
          }
        };
        ()
      }
    }
    ()
  };

  // Update LastPosition from Position
  with addSystem[(Position, LastPosition), Unit, Unit]() { { query } =>
    if (not((do getResource[GameOver]()).value)) {
      val doMove = (do getResource[MoveTimer]()).doMove;
      if (doMove) {
        query.foreachRW() { (_, values) =>
          values match {
            case (position, lastPosition) => {
              (position, LastPosition(position.value))
            }
          }
        };
      }
    } else {
      query.foreachRW() { (_, values) =>
        values match {
          case (position, lastPosition) => {
            (Position(lastPosition.value), lastPosition)
          }
        }
      };
    }
    ()
  };

  // Reset game (destroy all entities (with position at least))
  with addSystem[Unit, Position, Unit]() { { query } =>
    if ((do getResource[ResetGame]()).value) {
      do setResource[ResetGame](ResetGame(false));
      query.foreachRO() { (entity, _) =>
        do destroyEntity(entity);
        ()
      };
      initGame();
    }
    ()
  };

  initGame();

  do runWorld();

  ()
}