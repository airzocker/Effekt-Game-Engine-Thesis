import io
import io/time

import game_engine_lib/vector

extern type CanvasElement
extern type CanvasRenderingContext2D

interface Context {
  def fillStyle(color: String): Int
  def fillRect(pos: Vector2Int, size: Vector2Int): Unit
  def fillCircle(pos: Vector2Int, radius: Int): Unit
  def fillText(pos: Vector2Int, text: String): Unit
  def initFont(fontSize: Int): Unit
}

def whiteRectangle(pos: Vector2Int, size: Vector2Int) = {
  do fillStyle("white");
  do fillRect(pos, size);
}

def whiteCircle(pos: Vector2Int, radius: Int) = {
  do fillStyle("white");
  do fillCircle(pos, radius);
}

def blackBackground() = {
  do fillStyle("black");
  do fillRect(Vector2Int(0, 0), Vector2Int(getCanvasWidth(), getCanvasHeight()));
}

def whiteText(pos: Vector2Int, text: String) = {
  do fillText(pos, text);
}

def setFontSize(fontSize: Int) = {
  do initFont(fontSize);
}

def defaultContext[R] { prog: () => R / Context }: R / {} = {
  val canvas = getCanvas()
  val ctx = canvas.getContext;

  with handleContext(canvas, ctx);

  prog()
}

def handleContext[R](canvas: CanvasElement, ctx: CanvasRenderingContext2D) { prog: () => R / Context }: R / {} = {
  try { prog() }
  with Context {
    def fillStyle(color) = { jsFillStyle(ctx, color); resume(42) }
    def fillRect(pos, size) = { jsFillRect(ctx, pos.x, pos.y, size.x, size.y); resume(()) }
    def fillCircle(pos, radius) = { jsFillCircle(ctx, pos.x, pos.y, radius); resume(()) }
    def fillText(pos, text) = { jsFillText(ctx, pos.x, pos.y, text); resume(()) }
    def initFont(fontSize) = { jsInitFont(ctx, fontSize); resume(()) }
  }
}

def main() = eventloop(box {
  resizeCanvas();
  registerEvents();

  with defaultContext;
  
  var score1 = 0;
  var score2 = 0;
  
  val playAreaSize = Vector2Int(getCanvasHeight(), getCanvasHeight());

  setFontSize(playAreaSize.y / 12);

  val paddleSpeed = 0.8 * playAreaSize.y.toDouble();
  val paddleSize: Vector2Int = Vector2(0.02275 * playAreaSize.y.toDouble(), 0.065 * playAreaSize.y.toDouble()).round();
  // Play-area width is = canvas height, so the paddle's outer edge is exactly on the Play-area limit
  val playAreaMin: Vector2Int = Vector2(getCanvasWidth().toDouble() / 2.0 - 0.5 * playAreaSize.x.toDouble(), 0.0).round();
  val playAreaMax: Vector2Int = Vector2(getCanvasWidth().toDouble() / 2.0 + 0.5 * playAreaSize.x.toDouble(), playAreaSize.y.toDouble()).round();
  val paddleStartPosY = playAreaSize.y.toDouble() / 2.0 - paddleSize.y.toDouble() / 2.0;

  val ballSpeed = 0.65 * paddleSpeed;
  val ballRadius = round(0.0075 * playAreaSize.y.toDouble());
  val ballStartPos = Vector2(getCanvasWidth().toDouble() / 2.0, playAreaSize.y.toDouble() / 2.0);
  val ballStartDir = Vector2(1.0, 1.0).normalize();

  val startTime = getTime();
  var elapsedTime = 0.0;
  var deltaTime = 0.0;

  var paddle1Pos = Vector2(playAreaMin.x.toDouble(), paddleStartPosY);
  var paddle2Pos = Vector2(playAreaMax.x.toDouble() - paddleSize.x.toDouble(), paddleStartPosY);
  
  var ballPos = ballStartPos;
  var ballDir = ballStartDir;

  while (not(isInputEscape())) {
    // Loop needs wait() to give control flow back, otherwise JavaScript events will never be detected
    do await(do promise(box { wait(0) } ));

    val newElapsedTime = getTime() - startTime;
    deltaTime = newElapsedTime - elapsedTime;
    elapsedTime = newElapsedTime;

    var direction1 = 0;
    var direction2 = 0;
    if (isInput1Up()) {
      direction1 = direction1 - 1;
    }
    if (isInput1Down()) {
      direction1 = direction1 + 1;
    }
    if (isInput2Up()) {
      direction2 = direction2 - 1;
    }
    if (isInput2Down()) {
      direction2 = direction2 + 1;
    }
    paddle1Pos = paddle1Pos.setY(paddle1Pos.y + direction1.toDouble() * deltaTime * paddleSpeed);
    paddle2Pos = paddle2Pos.setY(paddle2Pos.y + direction2.toDouble() * deltaTime * paddleSpeed);
    if (paddle1Pos.y < playAreaMin.y.toDouble()) {
      paddle1Pos = paddle1Pos.setY(playAreaMin.y.toDouble());
    } else if (paddle1Pos.y > (playAreaMax.y - paddleSize.y).toDouble()) {
      paddle1Pos = paddle1Pos.setY((playAreaMax.y - paddleSize.y).toDouble());
    }
    if (paddle2Pos.y < playAreaMin.y.toDouble()) {
      paddle2Pos = paddle2Pos.setY(playAreaMin.y.toDouble());
    } else if (paddle2Pos.y > (playAreaMax.y - paddleSize.y).toDouble()) {
      paddle2Pos = paddle2Pos.setY((playAreaMax.y - paddleSize.y).toDouble());
    }
    
    ballPos = ballPos + ballDir * deltaTime * ballSpeed;
    if (ballPos.y < (playAreaMin.y + ballRadius).toDouble()) {
      ballPos = ballPos.setY(ballRadius.toDouble());
      ballDir = ballDir.setY(-1.0 * ballDir.y);
    } else if (ballPos.y > (playAreaMax.y - ballRadius).toDouble()) {
      ballPos = ballPos.setY((playAreaSize.y - ballRadius).toDouble());
      ballDir = ballDir.setY(-1.0 * ballDir.y);
    }

    var checkPaddle = paddle1Pos;
    if (ballDir.x > 0.0) {
      checkPaddle = paddle2Pos;
    }
    checkPaddle = checkPaddle + paddleSize.toVector2() / 2.0;
    val diff = ballPos - checkPaddle;
    if (diff.length() < ballRadius.toDouble() + paddleSize.y.toDouble() / 2.0) {
      ballDir = diff.normalize();
    }

    // 0 means continue, 1 or -1 indicates which side got a point
    var resetState = 0;
    if (ballPos.x < (playAreaMin.x + ballRadius).toDouble() && ballDir.x < 0.0) {
      resetState = 1;
    } else if (ballPos.x > (playAreaMax.x - ballRadius).toDouble() && ballDir.x > 0.0) {
      resetState = -1;
    }
    if (resetState != 0) {
      if (resetState == -1) {
        score1 = score1 + 1;
      } else {
        score2 = score2 + 1;
      }
      paddle1Pos = paddle1Pos.setY(paddleStartPosY);
      paddle2Pos = paddle2Pos.setY(paddleStartPosY);
      ballPos = ballStartPos;
      ballDir = Vector2(resetState.toDouble() * ballStartDir.x, ballStartDir.y);
    }

    blackBackground();
    whiteRectangle(paddle1Pos.round(), paddleSize);
    whiteRectangle(paddle2Pos.round(), paddleSize);
    whiteCircle(ballPos.round(), ballRadius);
    whiteText(Vector2Int(playAreaMin.x + (playAreaMax.x - playAreaMin.x) / 4, playAreaSize.y / 8), score1.show());
    whiteText(Vector2Int(playAreaMax.x - (playAreaMax.x - playAreaMin.x) / 4, playAreaSize.y / 8), score2.show());
  }
} )

extern io def resizeCanvas(): Unit =
  js "resizeCanvas()"

extern io def registerEvents(): Unit =
  js "registerEvents()"

extern pure def getCanvasWidth(): Int =
  js "getCanvasWidth()"

extern pure def getCanvasHeight(): Int =
  js "getCanvasHeight()"

extern pure def isInput1Up(): Bool =
  js "isInput1Up()"

extern pure def isInput1Down(): Bool =
  js "isInput1Down()"

extern pure def isInput2Up(): Bool =
  js "isInput2Up()"

extern pure def isInput2Down(): Bool =
  js "isInput2Down()"

extern pure def isInputEscape(): Bool =
  js "isInputEscape()"

extern pure def getTime(): Double =
  js "window.performance.now() / 1000.0"

extern pure def getCanvas(): CanvasElement =
  js "getCanvas()"

extern pure def getContext(canvas: CanvasElement): CanvasRenderingContext2D =
  js "(${canvas}).getContext('2d')"

extern io def jsFillStyle(context: CanvasRenderingContext2D, color: String): Unit =
  js "(${context}).fillStyle = (${color})"

extern io def jsFillRect(context: CanvasRenderingContext2D, x: Int, y: Int, width: Int, height: Int): Unit =
  js "(${context}).fillRect(${x}, ${y}, ${width}, ${height})"

extern io def jsFillCircle(context: CanvasRenderingContext2D, x: Int, y: Int, radius: Int): Unit =
  js "fillCircle(${context}, ${x}, ${y}, ${radius})"

extern io def jsInitFont(context: CanvasRenderingContext2D, fontSize: Int): Unit =
  js "initFont(${context}, ${fontSize})"

extern io def jsFillText(context: CanvasRenderingContext2D, x: Int, y: Int, text: String): Unit =
  js "(${context}).fillText(${text}, ${x}, ${y})"

extern js """

const canvas = document.getElementById('myCanvas');
let canvasWidth = 0;
let canvasHeight = 0;

let up1 = false;
let down1 = false;
let up2 = false;
let down2 = false;
let escape = false;

function getCanvas() {
  return canvas;
}

function initFont(ctx, fontSize) {
  ctx.font = 'bold ' + fontSize + 'px sans';
  ctx.textAlign = 'center';
}

function fillCircle(context, x, y, radius) {
  context.beginPath();
  context.arc(x, y, radius, 0, 2 * Math.PI);
  context.fill();
}

function resizeCanvas() {
  canvasWidth = window.innerWidth;
  canvasHeight = window.innerHeight;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
}

function registerEvents() {
  // Remove for now, because we don't want the canvas to be resizable during the game
  //window.addEventListener('resize', resizeCanvas);
  window.addEventListener('keydown', onKeyDown, true);
  window.addEventListener('keyup', onKeyUp, true);
}

function onKeyDown(event) {
  if (event.code == 'KeyW') {
    up1 = true;
  }
  if (event.code == 'KeyS') {
    down1 = true;
  }
  if (event.code == 'ArrowUp') {
    up2 = true;
  }
  if (event.code == 'ArrowDown') {
    down2 = true;
  }
  if (event.code == 'Escape') {
    escape = true;
  }
}

function onKeyUp(event) {
  if (event.code == 'KeyW') {
    up1 = false;
  }
  if (event.code == 'KeyS') {
    down1 = false;
  }
  if (event.code == 'ArrowUp') {
    up2 = false;
  }
  if (event.code == 'ArrowDown') {
    down2 = false;
  }
}

function getCanvasWidth() {
  return canvasWidth;
}

function getCanvasHeight() {
  return canvasHeight;
}

function isInput1Up() {
  return up1;
}

function isInput1Down() {
  return down1;
}

function isInput2Up() {
  return up2;
}

function isInput2Down() {
  return down2;
}

function isInputEscape() {
  return escape;
}

"""