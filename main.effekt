import io
import io/time

extern type CanvasElement
extern type CanvasRenderingContext2D

interface Context {
  def fillStyle(color: String): Int
  def fillRect(x: Int, y: Int, width: Int, height: Int): Unit
  def fillCircle(x: Int, y: Int, radius: Int): Unit
}

def whiteRectangle(x: Int, y: Int, width: Int, height: Int) = {
  do fillStyle("white");
  do fillRect(x, y, width, height)
}

def whiteCircle(x: Int, y: Int, radius: Int) = {
  do fillStyle("white");
  do fillCircle(x, y, radius);
}

def blackBackground() = {
  do fillStyle("black");
  do fillRect(0, 0, getCanvasWidth(), getCanvasHeight())
}

def defaultContext[R] { prog: () => R / Context }: R / {} = {
  val canvas = getCanvas()
  val ctx = canvas.getContext;

  with handleContext(canvas, ctx);

  prog()
}

def handleContext[R](canvas: CanvasElement, ctx: CanvasRenderingContext2D) { prog: () => R / Context }: R / {} = {
  try { prog() }
  with Context {
    def fillStyle(color) = { jsFillStyle(ctx, color); resume(42) }
    def fillRect(x, y, width, height) = { jsFillRect(ctx, x, y, width, height); resume(()) }
    def fillCircle(x, y, radius) = { jsFillCircle(ctx, x, y, radius); resume(()) }
  }
}

def vectorLength(x: Double, y: Double): Double = {
  sqrt(x * x + y * y)
}

def main() = eventloop(box {
  resizeCanvas();
  registerEvents();

  with defaultContext;
  
  val windowHeight = getCanvasHeight();
  val paddleSpeed = 0.8 * windowHeight.toDouble;
  val paddleHeight = round(0.05 * windowHeight.toDouble);
  val paddleWidth = round(0.3 * paddleHeight.toDouble);
  // Play-area width is = canvas height, so the paddle's outer edge is exactly on the Play-area limit
  val playAreaMinX = round(getCanvasWidth().toDouble / 2.0 - 0.5 * windowHeight.toDouble);
  val playAreaMaxX = round(getCanvasWidth().toDouble / 2.0 + 0.5 * windowHeight.toDouble);
  val paddle1PosX = playAreaMinX;
  val paddle2PosX = playAreaMaxX - paddleWidth;
  val paddleStartPosY = windowHeight / 2 - paddleHeight / 2;
  
  val ballSpeed = 0.75 * paddleSpeed;
  val ballRadius = round(0.0075 * windowHeight.toDouble);
  val ballStartPosX = getCanvasWidth() / 2;
  val ballStartPosY = windowHeight / 2;
  val ballStartDirX = 1.0 / sqrt(1.0);
  val ballStartDirY = 1.0 / sqrt(1.0);

  val startTime = getTime();
  var elapsedTime = 0.0;
  var deltaTime = 0.0;

  var paddle1PosY = paddleStartPosY;
  var paddle2PosY = paddleStartPosY;
  
  var ballPosX = ballStartPosX;
  var ballPosY = ballStartPosY;
  var ballDirX = ballStartDirX;
  var ballDirY = ballStartDirY;

  while (not(isInputEscape())) {
    do await(do promise(box { wait(0) } ));

    val newElapsedTime = getTime() - startTime;
    deltaTime = newElapsedTime - elapsedTime;
    elapsedTime = newElapsedTime;

    var direction1 = 0;
    var direction2 = 0;
    if (isInput1Up()) {
      direction1 = direction1 - 1;
    }
    if (isInput1Down()) {
      direction1 = direction1 + 1;
    }
    if (isInput2Up()) {
      direction2 = direction2 - 1;
    }
    if (isInput2Down()) {
      direction2 = direction2 + 1;
    }
    paddle1PosY = paddle1PosY + round(direction1.toDouble * deltaTime * paddleSpeed);
    paddle2PosY = paddle2PosY + round(direction2.toDouble * deltaTime * paddleSpeed);
    if (paddle1PosY < 0) {
      paddle1PosY = 0;
    } else if (paddle1PosY > windowHeight - paddleHeight) {
      paddle1PosY = windowHeight - paddleHeight;
    }
    if (paddle2PosY < 0) {
      paddle2PosY = 0;
    } else if (paddle2PosY > windowHeight - paddleHeight) {
      paddle2PosY = windowHeight - paddleHeight;
    }
    
    ballPosX = ballPosX + round(ballDirX * deltaTime * ballSpeed);
    ballPosY = ballPosY + round(ballDirY * deltaTime * ballSpeed);
    if (ballPosY < ballRadius) {
      ballPosY = ballRadius;
      ballDirY = -1.0 * ballDirY;
    } else if (ballPosY > windowHeight - ballRadius) {
      ballPosY = windowHeight - ballRadius;
      ballDirY = -1.0 * ballDirY;
    }

    var checkPaddleX = paddle1PosX;
    var checkPaddleY = paddle1PosY;
    if (ballDirX > 0.0) {
      checkPaddleX = paddle2PosX;
      checkPaddleY = paddle2PosY;
    }
    checkPaddleX = checkPaddleX + paddleWidth / 2;
    checkPaddleY = checkPaddleY + paddleHeight / 2;
    val diffX = (ballPosX - checkPaddleX).toDouble;
    val diffY = (ballPosY - checkPaddleY).toDouble;
    val dist = vectorLength(diffX, diffY);
    if (dist < ballRadius.toDouble + paddleHeight.toDouble / 2.0) {
      ballDirX = diffX / dist;
      ballDirY = diffY / dist;
    }

    // 0 means continue, 1 or -1 indicates which side got a point
    var resetState = 0;
    if (ballPosX < playAreaMinX + ballRadius && ballDirX < 0.0) {
      resetState = 1;
    } else if (ballPosX > playAreaMaxX - ballRadius && ballDirX > 0.0) {
      resetState = -1;
    }
    if (resetState != 0) {
      paddle1PosY = paddleStartPosY;
      paddle2PosY = paddleStartPosY;
      ballPosX = ballStartPosX;
      ballPosY = ballStartPosY;
      ballDirX = resetState.toDouble * ballStartDirX;
      ballDirY = ballStartDirY;
    }

    blackBackground();
    whiteRectangle(paddle1PosX, paddle1PosY, paddleWidth, paddleHeight);
    whiteRectangle(paddle2PosX, paddle2PosY, paddleWidth, paddleHeight);
    whiteCircle(ballPosX, ballPosY, ballRadius);
  }
} )

extern io def resizeCanvas(): Unit =
  js "resizeCanvas()"

extern io def registerEvents(): Unit =
  js "registerEvents()"

extern pure def getCanvasWidth(): Int =
  js "getCanvasWidth()"

extern pure def getCanvasHeight(): Int =
  js "getCanvasHeight()"

extern pure def isInput1Up(): Bool =
  js "isInput1Up()"

extern pure def isInput1Down(): Bool =
  js "isInput1Down()"

extern pure def isInput2Up(): Bool =
  js "isInput2Up()"

extern pure def isInput2Down(): Bool =
  js "isInput2Down()"

extern pure def isInputEscape(): Bool =
  js "isInputEscape()"

extern pure def getTime(): Double =
  js "window.performance.now() / 1000.0"

extern pure def getCanvas(): CanvasElement =
  js "getCanvas()"

extern pure def getContext(canvas: CanvasElement): CanvasRenderingContext2D =
  js "(${canvas}).getContext('2d')"

extern io def jsFillStyle(context: CanvasRenderingContext2D, color: String): Unit =
  js "(${context}).fillStyle = (${color})"

extern io def jsFillRect(context: CanvasRenderingContext2D, x: Int, y: Int, width: Int, height: Int): Unit =
  js "(${context}).fillRect(${x}, ${y}, ${width}, ${height})"

extern io def jsFillCircle(context: CanvasRenderingContext2D, x: Int, y: Int, radius: Int): Unit =
  js """
    (${context}).beginPath();
    (${context}).arc(${x}, ${y}, ${radius}, 0, 2 * Math.PI);
    (${context}).fill();
  """

extern js """

const canvas = document.getElementById('myCanvas');
let canvasWidth = 0;
let canvasHeight = 0;

let up1 = false;
let down1 = false;
let up2 = false;
let down2 = false;
let escape = false;

function getCanvas() {
  return canvas;
}

function resizeCanvas() {
  canvasWidth = window.innerWidth;
  canvasHeight = window.innerHeight;
  canvas.width = canvasWidth;
  canvas.height = canvasHeight;
}

function registerEvents() {
  // Remove for now, because we don't want the canvas to be resizable during the game
  //window.addEventListener('resize', resizeCanvas);
  window.addEventListener('keydown', onKeyDown, true);
  window.addEventListener('keyup', onKeyUp, true);
}

function onKeyDown(event) {
  if (event.code == 'KeyW') {
    up1 = true;
  }
  if (event.code == 'KeyS') {
    down1 = true;
  }
  if (event.code == 'ArrowUp') {
    up2 = true;
  }
  if (event.code == 'ArrowDown') {
    down2 = true;
  }
  if (event.code == 'Escape') {
    escape = true;
  }
}

function onKeyUp(event) {
  if (event.code == 'KeyW') {
    up1 = false;
  }
  if (event.code == 'KeyS') {
    down1 = false;
  }
  if (event.code == 'ArrowUp') {
    up2 = false;
  }
  if (event.code == 'ArrowDown') {
    down2 = false;
  }
}

function getCanvasWidth() {
  return canvasWidth;
}

function getCanvasHeight() {
  return canvasHeight;
}

function isInput1Up() {
  return up1;
}

function isInput1Down() {
  return down1;
}

function isInput2Up() {
  return up2;
}

function isInput2Down() {
  return down2;
}

function isInputEscape() {
  return escape;
}

"""